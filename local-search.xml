<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>6.S081-Lab11: networking</title>
    <link href="/2021/07/11/6-S081-Lab11-networking/"/>
    <url>/2021/07/11/6-S081-Lab11-networking/</url>
    
    <content type="html"><![CDATA[<h2 id="Lab11-networking"><a href="#Lab11-networking" class="headerlink" title="Lab11: networking"></a>Lab11: networking</h2><p>Lab11为xv6编写网卡驱动，使得网络协议栈（IP、UDP、ARP）能够正常运行。</p><h4 id="networking"><a href="#networking" class="headerlink" title="networking"></a>networking</h4><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><ol><li>实现<code>e1000_transmit()</code></li></ol><p><code>e1000_transmit()</code>函数接收一mbuf，mbuf包含了将要发送的以太网帧。由于网卡采用DMA传输数据，要发送数据帧，要告诉DMA控制器数据帧的起始内存地址和长度。因此内存中维护了<code>tx_ring</code>环形传送描述队列，网卡寄存器维护了<code>E1000_TDH</code>作为队列头指针，<code>E1000_TDT</code>作为队列尾指针，结构如下图所示：</p><img src="https://whileskies-pic.oss-cn-beijing.aliyuncs.com/20210711171635.png" alt="image-20210711171628026" style="zoom: 50%;" /><p>初始化时所有队列中的描述符状态均设为<code>E1000_TXD_STAT_DD</code>，根据提示，当tail的<code>E1000_TXD_STAT_DD</code>为0时，代表网卡还未取走该帧数据，则当前队列满了，返回错误。</p><p>网卡每次会从head处取数据，取完数据将<code>E1000_TXD_STAT_DD</code>状态设为1，代表传送完成，但是只有在描述符拥有<code>E1000_TXD_CMD_RS</code>命令时才设置<code>E1000_TXD_STAT_DD</code>。</p><p>此外以太网帧的MTU为1500，一个缓冲区的大小为2048，因此不需要进行帧的划分，因此每个传送数据的描述命令应加上<code>E1000_TXD_CMD_EOP</code>，代表数据包的结束。</p><p>可能多个线程同时调用<code>e1000_transmit()</code>来传送数据，需要为其加锁互斥访问。</p><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">e1000_transmit</span><span class="hljs-params">(struct mbuf *m)</span></span><br><span class="hljs-function"></span>&#123;<br>  acquire(&amp;e1000_lock);<br><br>  <span class="hljs-keyword">int</span> tail = regs[E1000_TDT];<br>  <span class="hljs-keyword">if</span>(!(tx_ring[tail].status &amp; E1000_TXD_STAT_DD))&#123;<br>    release(&amp;e1000_lock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  <br>  <span class="hljs-keyword">if</span>(tx_mbufs[tail])<br>    mbuffree(tx_mbufs[tail]);<br>  <br>  <span class="hljs-built_in">memset</span>(&amp;tx_ring[tail], <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(struct tx_desc));<br>  tx_ring[tail].cmd = (E1000_TXD_CMD_EOP | E1000_TXD_CMD_RS);<br>  tx_ring[tail].addr = (uint64)m-&gt;head;<br>  tx_ring[tail].length = m-&gt;len;<br>  tx_mbufs[tail] = m;<br><br>  regs[E1000_TDT] = (tail + <span class="hljs-number">1</span>) % TX_RING_SIZE;<br>  <br>  release(&amp;e1000_lock);<br> <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>实现实现<code>e1000_recv()</code></li></ol><p>网卡接收到数据并根据<code>rx_ring</code>环形接收描述队列将数据通过DMA传送到内存指定位置，设置<code>E1000_RXD_STAT_DD</code>标记，并产生中断，<code>e1000_recv()</code>被调用。</p><p>该函数需要扫描<code>rx_ring</code>传递每一个接收到的包到网络协议栈，调用<code>net_rx()</code>函数传送，之后应该分配一个新的缓冲区替换到相应描述符中。</p><p><code>e1000_transmit()</code>和<code>e1000_recv()</code>并不共享数据结构，相互独立，不会相互影响，因此可以为<code>e1000_recv()</code>单独加上另一把锁，防止在一个线程在<code>e1000_recv()</code>执行时，另外一个CPU产生了<code>e1000_intr</code>中断。</p><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">e1000_lockrx</span>;</span><br><br><span class="hljs-comment">// e1000_init()</span><br>initlock(&amp;e1000_lockrx, <span class="hljs-string">&quot;e1000_rx&quot;</span>);<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">e1000_recv</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  acquire(&amp;e1000_lockrx);<br><br>  <span class="hljs-keyword">int</span> i = (regs[E1000_RDT] + <span class="hljs-number">1</span>) % RX_RING_SIZE;<br>  <span class="hljs-keyword">while</span>(rx_ring[i].status &amp; E1000_RXD_STAT_DD)&#123;<br>    rx_mbufs[i]-&gt;len = rx_ring[i].length;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mbuf</span> *<span class="hljs-title">rb</span> =</span> rx_mbufs[i];<br><br>    rx_mbufs[i] = mbufalloc(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (!rx_mbufs[i])<br>      panic(<span class="hljs-string">&quot;e1000&quot;</span>);<br>    rx_ring[i].addr = (uint64) rx_mbufs[i]-&gt;head;<br>    rx_ring[i].status = <span class="hljs-number">0</span>;<br>    regs[E1000_RDT] = i;<br><br>    net_rx(rb);<br><br>    i = (regs[E1000_RDT] + <span class="hljs-number">1</span>) % RX_RING_SIZE;<br>  &#125;<br><br>  release(&amp;e1000_lockrx);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="实验测试"><a href="#实验测试" class="headerlink" title="实验测试"></a>实验测试</h4><p><img src="https://whileskies-pic.oss-cn-beijing.aliyuncs.com/20210711175600.png" alt="image-20210711175600483"></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p><a href="https://github.com/whileskies/xv6-labs-2020/tree/net">https://github.com/whileskies/xv6-labs-2020/tree/net</a></p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>6.S081</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.S081-Lab10: mmap</title>
    <link href="/2021/07/11/6-S081-Lab10-mmap/"/>
    <url>/2021/07/11/6-S081-Lab10-mmap/</url>
    
    <content type="html"><![CDATA[<h2 id="Lab10-mmap"><a href="#Lab10-mmap" class="headerlink" title="Lab10: mmap"></a>Lab10: mmap</h2><p>Lab10需要为xv6实现简易版的mmap和munmap系统调用，mmap允许对进程的地址空间进行详细控制，可以用来进程间共享内存、将文件映射到进程地址空间等，本lab仅仅实现内存映射文件。</p><h4 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h4><h5 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h5><p>mmap的接口格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">mmap</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *addr, <span class="hljs-keyword">size_t</span> length, <span class="hljs-keyword">int</span> prot, <span class="hljs-keyword">int</span> flags, <span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">off_t</span> offset)</span></span><br></code></pre></td></tr></table></figure><p>在本lab中假设addr总是0，由内核决定所映射文件的虚拟地址，当返回0xffffffffffffffff 代表失败；length是映射的字节数，可能和文件大小不一致；prot表示被映射的内存是否可读、可写、可执行，可以假设prot是可读、可写或可读可写的；flags要么是MAP_SHARED，表示对于所映射内存的修改应该写回文件，要么是MAP_PRIVATE，表示不用写回文件，不用考虑其他的bits；fd是被映射文件的文件描述符；offset是文件的偏移，可以假定总为0（映射文件时总是从文件起始进行映射）。</p><p>如果多个进程映射同一MAP_SHARED文件，可以不用实现共享同一物理页。</p><p>munmap的接口格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">munmap</span><span class="hljs-params">(uint64 addr, <span class="hljs-keyword">int</span> length)</span></span><br></code></pre></td></tr></table></figure><p>munmap应该移除在参数指定范围的mmap映射，如果进程修改了映射的内存，并且是MAP_SHARED的，修改应该首先写回文件；可以假定munmap取消映射的范围要么起始于映射区域的开始，要么结束与映射区域的结尾，要么整个区域，也即不会是整个映射区域中打一个孔，将剩余的映射区域分为两个部分。</p><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><ol><li>定义VMA</li></ol><p>一个进程可以多次调用mmap映射多个文件，因此进程应记录每一次所映射的虚拟地址区域，定义vma代表进程虚拟地址映射的一个区域，字段包括是否被使用、区域的起始地址、结束地址、文件描述符、权限等。</p><p>每个进程包含多个VMA，最大为16个，代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// param.h</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NVMA         16    <span class="hljs-comment">// maximum number of vma</span></span><br><br><span class="hljs-comment">// proc.h</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vma</span> &#123;</span><br>  <span class="hljs-keyword">int</span> used;<br>  uint64 addr;<br>  <span class="hljs-keyword">int</span> length;<br>  <span class="hljs-keyword">int</span> permissions;<br>  <span class="hljs-keyword">int</span> flags;<br>  <span class="hljs-keyword">int</span> offset;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">f</span>;</span><br>  uint64 start;<br>  uint64 end;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> &#123;</span><br>  <span class="hljs-comment">// 省略</span><br>  <span class="hljs-keyword">char</span> name[<span class="hljs-number">16</span>];               <span class="hljs-comment">// Process name (debugging)</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vma</span> <span class="hljs-title">vmas</span>[<span class="hljs-title">NVMA</span>];</span>       <span class="hljs-comment">// Virtual Memory Area</span><br>&#125;;<br></code></pre></td></tr></table></figure><ol start="2"><li>实现mmap</li></ol><p><code>mmap()</code>实现为一系统调用，首先读取系统调用参数，如果该mmap是MAP_SHARED的，但是映射内存标志为不可写的，则返回错误。</p><p>从VMA数组中寻找一未使用的VMA，之后确定映射的起始地址，起始地址为已使用的VMA中最大结束地址，如果没有则默认为VMA_BASE（4GB开始），之后设置VMA即可，这里映射的区域地址范围为[start, end)，左闭右开。</p><p>由于mmap调用使用了文件，因此应该为该文件的引用计数+1，防止该文件变量被回收。</p><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// sysfile.c</span><br><span class="hljs-function">uint64</span><br><span class="hljs-function"><span class="hljs-title">sys_mmap</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> i;<br>  uint64 addr;<br>  <span class="hljs-keyword">int</span> prot, flags, length, offset;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">f</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vma</span> *<span class="hljs-title">a</span> =</span> <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">if</span>(argaddr(<span class="hljs-number">0</span>, &amp;addr) || argint(<span class="hljs-number">1</span>, &amp;length) || argint(<span class="hljs-number">2</span>, &amp;prot) ||<br>    argint(<span class="hljs-number">3</span>, &amp;flags) || argfd(<span class="hljs-number">4</span>, <span class="hljs-number">0</span>, &amp;f) &lt; <span class="hljs-number">0</span> || argint(<span class="hljs-number">5</span>, &amp;offset) &lt; <span class="hljs-number">0</span> )<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  <br>  <span class="hljs-keyword">if</span>((flags &amp; MAP_SHARED) &amp;&amp; !f-&gt;writable &amp;&amp; (prot &amp; PROT_WRITE))<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; NVMA; i++)&#123;<br>    <span class="hljs-keyword">if</span>(!p-&gt;vmas[i].used)&#123;<br>      a = &amp;p-&gt;vmas[i];<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span>(a == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>  uint64 maxend = VMA_BASE;<br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; NVMA; i++)&#123;<br>    <span class="hljs-keyword">if</span>(p-&gt;vmas[i].used &amp;&amp; p-&gt;vmas[i].end &gt; maxend)<br>      maxend = p-&gt;vmas[i].end;<br>  &#125;<br>  <br>  a-&gt;used = <span class="hljs-number">1</span>;<br>  a-&gt;start = maxend;<br>  a-&gt;end = PGROUNDUP(a-&gt;start + length);<br>  a-&gt;addr = a-&gt;start;<br>  a-&gt;length = a-&gt;end - a-&gt;start;<br>  a-&gt;f = f;<br>  a-&gt;offset = offset;<br>  a-&gt;permissions = prot;<br>  a-&gt;flags = flags;<br><br>  filedup(f);<br><br>  <span class="hljs-keyword">return</span> a-&gt;start;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>实现mmap缺页中断处理</li></ol><p>上面的mmap系统调用只是为进程标记了映射区域，实际上并未映射物理内存，这里仍然是lazy分配的思想，等到进程实际访问映射区域时，产生缺页中断，再为所缺的虚拟页分配物理页，通过页表建立映射，并读取文件到物理页中，中断返回后进程再次访问该地址可正常访问该文件的映射。</p><p>读取文件时的偏移应为该文件在vma中起始偏移 + 该页与vma起始页的偏移。</p><p>代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// vm.c</span><br><span class="hljs-comment">// Mmap pages does not exist, page fault will occur.</span><br><span class="hljs-comment">// Alloc a physical page and read the file to it.</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> </span><br><span class="hljs-function"><span class="hljs-title">mmap_pgfault</span><span class="hljs-params">(uint64 stval, struct proc *p)</span></span><br><span class="hljs-function"></span>&#123;<br>  stval = PGROUNDDOWN(stval);<br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vma</span> *<span class="hljs-title">a</span> =</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// Which vma?</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; NVMA; i++)&#123;<br>    <span class="hljs-keyword">if</span>(p-&gt;vmas[i].used &amp;&amp; stval &gt;= p-&gt;vmas[i].start &amp;&amp; stval &lt; p-&gt;vmas[i].end)&#123;<br>      a = &amp;p-&gt;vmas[i];<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span>(a == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>  <span class="hljs-keyword">char</span> *pa = kalloc();<br>  <span class="hljs-keyword">if</span>(pa == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  <span class="hljs-built_in">memset</span>(pa, <span class="hljs-number">0</span>, PGSIZE);<br><br>  <span class="hljs-keyword">int</span> perm = PTE_U;<br>  <span class="hljs-keyword">if</span>(a-&gt;permissions &amp; PROT_READ)<br>    perm |= PTE_R;<br>  <span class="hljs-keyword">if</span>(a-&gt;permissions &amp; PROT_WRITE)<br>    perm |= PTE_W;<br>  <span class="hljs-keyword">if</span>(mappages(p-&gt;pagetable, PGROUNDDOWN(stval), PGSIZE, (uint64)pa, perm) != <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  <br>  uint64 off = stval - a-&gt;start + a-&gt;offset;<br>  ilock(a-&gt;f-&gt;ip);<br>  <span class="hljs-keyword">if</span>(readi(a-&gt;f-&gt;ip, <span class="hljs-number">0</span>, (uint64)pa, off, PGSIZE) &lt;= <span class="hljs-number">0</span>)&#123;<br>    iunlock(a-&gt;f-&gt;ip);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  iunlock(a-&gt;f-&gt;ip);<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// trap.c</span><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (r_scause() == <span class="hljs-number">13</span> || r_scause() == <span class="hljs-number">15</span>) &#123;<br>    uint64 stval = r_stval();<br>    <span class="hljs-keyword">if</span>(mmap_pgfault(stval, p) != <span class="hljs-number">0</span>)&#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());<br>      p-&gt;killed = <span class="hljs-number">1</span>;<br>    &#125;<br><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((which_dev = devintr()) != <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-comment">// ok</span><br>  &#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>实现munmap</li></ol><p><code>munmap()</code>取消映射区域的一部分，首先要找到所属的vma，取消的映射区域分为三种情况：取消vma起始地址的一段映射、取消以vma结束地址结束的一段映射、取消整个vma映射，根据三种情况得出所取消映射区域的起始地址（unstart）与长度（unlen），并更新取消一段区域后的vma。</p><p>取消映射区域的起始地址需要按页对其，长度也需要是页大小的整数倍。</p><p>如果该vma的标志为MAP_SHARED时，应该把所取消的区域的修改写回到文件中去，这里为了简单不考虑页表中的dirty位，直接写回文件；如果取消映射的页还没有通过<code>mmap_pgfault()</code>映射物理页，也就代表着没有访问修改，则不用写回。</p><p>如果取消了vma整段区域的映射，代表着该文件映射的取消，应该减少该文件的引用计数。</p><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// vm.c</span><br><span class="hljs-comment">// Whether the virtual address is mapped.</span><br><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">vm_exists</span><span class="hljs-params">(<span class="hljs-keyword">pagetable_t</span> pagetable, uint64 va)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">pte_t</span> *pte;<br>  <span class="hljs-keyword">return</span> (pte = walk(pagetable, va, <span class="hljs-number">0</span>)) != <span class="hljs-number">0</span> &amp;&amp; (*pte &amp; PTE_V) != <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//Find the VMA for the address range and unmap the specified pages.</span><br><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">munmap</span><span class="hljs-params">(uint64 addr, <span class="hljs-keyword">int</span> length)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vma</span> *<span class="hljs-title">a</span> =</span> <span class="hljs-number">0</span>;<br>  addr = PGROUNDDOWN(addr);<br><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; NVMA; i++)&#123;<br>    <span class="hljs-keyword">if</span>(p-&gt;vmas[i].used &amp;&amp; addr &gt;= p-&gt;vmas[i].start &amp;&amp; addr &lt; p-&gt;vmas[i].end)&#123;<br>      a = &amp;p-&gt;vmas[i];<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (a == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>  uint64 unstart, unlen;<br>  uint64 start = a-&gt;start, offset = a-&gt;offset, orilen = a-&gt;length;<br><br>  <span class="hljs-keyword">if</span>(addr == a-&gt;start)&#123;<br>    <span class="hljs-comment">// Unmap at the start</span><br>    unstart = addr;<br>    unlen = PGROUNDUP(length) &lt; a-&gt;length ? PGROUNDUP(length) : a-&gt;length;<br><br>    a-&gt;start = unstart + unlen; <br>    a-&gt;length = a-&gt;end - a-&gt;start;<br>    a-&gt;offset = a-&gt;offset + unlen;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(addr + length &gt;= a-&gt;end)&#123;<br>    <span class="hljs-comment">// Unmap at the end</span><br>    unstart = addr;<br>    unlen = a-&gt;end - unstart;<br><br>    a-&gt;end = unstart;<br>    a-&gt;length = a-&gt;end - a-&gt;start;<br>  &#125; <span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-comment">// Unmap the whole region</span><br>    unstart = a-&gt;start;<br>    unlen = a-&gt;end - a-&gt;start;<br>  &#125;<br>  <br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; unlen / PGSIZE; i++)&#123;<br>    uint64 va = unstart + i * PGSIZE;<br>    <span class="hljs-comment">// May not be alloced due to lazy alloc through page fault.</span><br>    <span class="hljs-keyword">if</span>(vm_exists(p-&gt;pagetable, va))&#123;<br>      <span class="hljs-keyword">if</span>(a-&gt;flags &amp; MAP_SHARED)&#123;<br>        munmap_writeback(va, PGSIZE, start, offset, a);<br>      &#125;<br><br>      uvmunmap(p-&gt;pagetable, va, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span>(unlen == orilen)&#123;<br>    fileclose(a-&gt;f);<br>    a-&gt;used = <span class="hljs-number">0</span>;<br>  &#125;<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// sysfile.c</span><br><span class="hljs-function">uint64</span><br><span class="hljs-function"><span class="hljs-title">sys_munmap</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  uint64 addr;<br>  <span class="hljs-keyword">int</span> length;<br><br>  <span class="hljs-keyword">if</span>(argaddr(<span class="hljs-number">0</span>, &amp;addr) || argint(<span class="hljs-number">1</span>, &amp;length))<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  <br>  <span class="hljs-keyword">return</span> munmap(addr, length);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li>实现munmap_writeback</li></ol><p><code>munmap_writeback()</code>用于取消映射时将修改的映射页写回文件，写回时应注意写文件的起始偏移，与读文件类似，写偏移为该文件在vma中起始偏移 + 该页与vma起始页的偏移，此外该文件剩余大小不足一页大小时，应该按照实际剩余大小来写。</p><p>写文件时和<code>filewrite()</code>类似，将写操作打包为多次日志事务来写。</p><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// vm.c</span><br><span class="hljs-comment">// If an unmapped page has been modified and the file is mapped MAP_SHARED, </span><br><span class="hljs-comment">// write the page back to the file. </span><br><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">munmap_writeback</span><span class="hljs-params">(uint64 unstart, uint64 unlen, uint64 start, uint64 offset, struct vma *a)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">f</span> =</span> a-&gt;f;<br>  uint off = unstart - start + offset;<br>  uint size;<br><br>  ilock(f-&gt;ip);<br>  size = f-&gt;ip-&gt;size;<br>  iunlock(f-&gt;ip);<br><br>  <span class="hljs-keyword">if</span>(off &gt;= size) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>  uint n = unlen &lt; size - off ? unlen : size - off;<br><br>  <span class="hljs-keyword">int</span> r, ret = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">int</span> max = ((MAXOPBLOCKS<span class="hljs-number">-1</span><span class="hljs-number">-1</span><span class="hljs-number">-2</span>) / <span class="hljs-number">2</span>) * BSIZE;<br>  <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span>(i &lt; n)&#123;<br>    <span class="hljs-keyword">int</span> n1 = n - i;<br>    <span class="hljs-keyword">if</span>(n1 &gt; max)<br>      n1 = max;<br><br>    begin_op();<br>    ilock(f-&gt;ip);<br>    r = writei(f-&gt;ip, <span class="hljs-number">1</span>, unstart, off + i, n1);<br>    iunlock(f-&gt;ip);<br>    end_op();<br><br>    <span class="hljs-keyword">if</span>(r != n1)&#123;<br>      <span class="hljs-comment">// error from writei</span><br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    i += r;<br>  &#125;<br>  ret = (i == n ? n : <span class="hljs-number">-1</span>);<br><br>  <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="6"><li>修改exit</li></ol><p>进程退出时应该取消所有的mmap映射，直接调用<code>munmap()</code>函数取消每一个使用中的vma的映射即可，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// proc.c/exit</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; NVMA; i++)&#123;<br>    <span class="hljs-keyword">if</span>(p-&gt;vmas[i].used)&#123;<br>      munmap(p-&gt;vmas[i].start, p-&gt;vmas[i].length);<br>      p-&gt;vmas[i].used = <span class="hljs-number">0</span>;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><ol start="7"><li>修改fork</li></ol><p>当调用<code>fork()</code>时，子进程也需要复制父进程的映射，直接复制父进程的vma即可，不过需要为文件的引用计数+1，这里实现时不考虑父进程与子进程共享相同的物理页，如果共享的话，实现和COW fork类似，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// proc.c</span><br><span class="hljs-comment">// Copy vmas of parent proc for mmap</span><br><span class="hljs-comment">// Need to increase file reference count</span><br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">fork_mmap</span><span class="hljs-params">(struct proc *np, struct proc *p)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; NVMA; i++)&#123;<br>    <span class="hljs-keyword">if</span>(p-&gt;vmas[i].used)&#123;<br>      np-&gt;vmas[i] = p-&gt;vmas[i];<br>      filedup(np-&gt;vmas[i].f);<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// proc.c/fork</span><br>safestrcpy(np-&gt;name, p-&gt;name, <span class="hljs-keyword">sizeof</span>(p-&gt;name));<br><br>fork_mmap(np, p);<br><br>pid = np-&gt;pid;<br></code></pre></td></tr></table></figure><h4 id="实验测试"><a href="#实验测试" class="headerlink" title="实验测试"></a>实验测试</h4><p><img src="https://whileskies-pic.oss-cn-beijing.aliyuncs.com/20210708130511.png" alt="image-20210708130504265"></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p><a href="https://github.com/whileskies/xv6-labs-2020/tree/mmap">https://github.com/whileskies/xv6-labs-2020/tree/mmap</a></p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>6.S081</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.S081-Lab9: file system</title>
    <link href="/2021/07/11/6-S081-Lab9-file-system/"/>
    <url>/2021/07/11/6-S081-Lab9-file-system/</url>
    
    <content type="html"><![CDATA[<h2 id="Lab9-file-system"><a href="#Lab9-file-system" class="headerlink" title="Lab9: file system"></a>Lab9: file system</h2><p>lab9是为xv6文件系统增加支持大文件的功能以及软链接功能。</p><h4 id="Large-files"><a href="#Large-files" class="headerlink" title="Large files"></a>Large files</h4><h5 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h5><p>当前的xv6文件被限制在268个块内， 每一块1024字节，这个限制由于xv6的inode结点包含12个直接块号，一个单一的间接块号，间接块号可以存储256个数据块块号，因此总共是12 + 256 = 268块。</p><p>该部分需要增加xv6文件的最大大小，通过为xv6引入二级间接块号来增加文件大小最大值，二级间接块号包括256个一级间接块号，每个一级间接块号又可以存储256个数据块块号，因此最大文件可以达到65803 块（256 * 256 + 256 + 11块，牺牲了一个直接块号作为二级间接块号地址）。</p><h5 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h5><ol><li>修改inode结构</li></ol><p>由于需要引入二级间接块号，需要牺牲一个直接块号，因此需要修改inode的结构以修改布局，修改后inode有11个直接块号、1个一级间接块号地址、1个二级间接块号地址，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// fs.h</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NDIRECT 11</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DINDIRECTI (NDIRECT + 1)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NINDIRECT (BSIZE / sizeof(uint))</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXFILE (NDIRECT + NINDIRECT + NINDIRECT * NINDIRECT</span><br><br><span class="hljs-comment">// file.h</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> &#123;</span><br>  uint dev;           <span class="hljs-comment">// Device number</span><br>  uint inum;          <span class="hljs-comment">// Inode number</span><br>  <span class="hljs-keyword">int</span> ref;            <span class="hljs-comment">// Reference count</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sleeplock</span> <span class="hljs-title">lock</span>;</span> <span class="hljs-comment">// protects everything below here</span><br>  <span class="hljs-keyword">int</span> valid;          <span class="hljs-comment">// inode has been read from disk?</span><br><br>  <span class="hljs-keyword">short</span> type;         <span class="hljs-comment">// copy of disk inode</span><br>  <span class="hljs-keyword">short</span> major;<br>  <span class="hljs-keyword">short</span> minor;<br>  <span class="hljs-keyword">short</span> nlink;<br>  uint size;<br>  uint addrs[NDIRECT+<span class="hljs-number">2</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><ol start="2"><li>修改<code>fs.c/bmap()</code></li></ol><p><code>bmap()</code>函数将文件内块号映射为磁盘块号，如果不存在则会为其从bitmap寻找一空闲数据块，并将寻找到的数据块号添加到inode中，建立相应的映射。</p><p>如果文件内块号位于一级间接块号的范围内，则应该先根据一级间接块号地址找到存放一级间接块号的数据块，如果不存在则分配，再根据一级间接块号中的块号地址，找到具体的数据块，如果不存在则分配。</p><p>二级间接块号也是类似的，只不过多了一层查找过程，修改后的inode结构如下图所示：</p><img src="https://whileskies-pic.oss-cn-beijing.aliyuncs.com/20210630153348.png" alt="image-20210630153348525" style="zoom: 67%;" /><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> uint</span><br><span class="hljs-function"><span class="hljs-title">bmap</span><span class="hljs-params">(struct inode *ip, uint bn)</span></span><br><span class="hljs-function"></span>&#123;<br>  uint addr, addr2, *a, *a2;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">bp</span>, *<span class="hljs-title">bp2</span>;</span><br><br>  <span class="hljs-keyword">if</span>(bn &lt; NDIRECT)&#123;<br>    <span class="hljs-keyword">if</span>((addr = ip-&gt;addrs[bn]) == <span class="hljs-number">0</span>)<br>      ip-&gt;addrs[bn] = addr = balloc(ip-&gt;dev);<br>    <span class="hljs-keyword">return</span> addr;<br>  &#125;<br>  bn -= NDIRECT;<br><br>  <span class="hljs-keyword">if</span>(bn &lt; NINDIRECT)&#123;<br>    <span class="hljs-comment">// Load indirect block, allocating if necessary.</span><br>    <span class="hljs-keyword">if</span>((addr = ip-&gt;addrs[NDIRECT]) == <span class="hljs-number">0</span>)<br>      ip-&gt;addrs[NDIRECT] = addr = balloc(ip-&gt;dev);<br>    bp = bread(ip-&gt;dev, addr);<br>    a = (uint*)bp-&gt;data;<br>    <span class="hljs-keyword">if</span>((addr = a[bn]) == <span class="hljs-number">0</span>)&#123;<br>      a[bn] = addr = balloc(ip-&gt;dev);<br>      log_write(bp);<br>    &#125;<br>    brelse(bp);<br>    <span class="hljs-keyword">return</span> addr;<br>  &#125;<br>  <br>  bn -= NINDIRECT;<br><br>  <span class="hljs-keyword">if</span>(bn &lt; NINDIRECT * NINDIRECT)&#123;<br>    uint dbn = bn / NINDIRECT;<br>    uint dbnoff = bn % NINDIRECT;<br><br>    <span class="hljs-comment">// Load doubly-indirect block, allocating if necessary.</span><br>    <span class="hljs-keyword">if</span>((addr = ip-&gt;addrs[DINDIRECTI]) == <span class="hljs-number">0</span>)<br>      ip-&gt;addrs[DINDIRECTI] = addr = balloc(ip-&gt;dev);<br>    bp = bread(ip-&gt;dev, addr);<br>    <br>    a = (uint*)bp-&gt;data;<br>    <span class="hljs-keyword">if</span>((addr2 = a[dbn]) == <span class="hljs-number">0</span>)&#123;<br>      a[dbn] = addr2 = balloc(ip-&gt;dev);<br>      log_write(bp);<br>    &#125;<br>    brelse(bp);<br><br>    <span class="hljs-comment">//printf(&quot;addr2: %d\n&quot;, addr2);</span><br>    bp2 = bread(ip-&gt;dev, addr2);<br>    a2 = (uint*)bp2-&gt;data;<br>    <span class="hljs-keyword">if</span>((addr = a2[dbnoff]) == <span class="hljs-number">0</span>)&#123;<br>      a2[dbnoff] = addr = balloc(ip-&gt;dev);<br>      log_write(bp2);<br>    &#125;<br>    brelse(bp2);<br><br>    <span class="hljs-keyword">return</span> addr;<br>  &#125;<br><br>  panic(<span class="hljs-string">&quot;bmap: out of range&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>修改<code>fs.c/itrunc()</code></li></ol><p>有增加映射就有删除映射，<code>itrunc()</code>用于删除整个文件内容，则需要查找inode，删除所占有的所有数据块，包括一级间接块、二级间接块，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">itrunc</span><span class="hljs-params">(struct inode *ip)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> i, j;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">bp</span>, *<span class="hljs-title">bp2</span>;</span><br>  uint *a, *a2;<br><br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; NDIRECT; i++)&#123;<br>    <span class="hljs-keyword">if</span>(ip-&gt;addrs[i])&#123;<br>      bfree(ip-&gt;dev, ip-&gt;addrs[i]);<br>      ip-&gt;addrs[i] = <span class="hljs-number">0</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span>(ip-&gt;addrs[NDIRECT])&#123;<br>    bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);<br>    a = (uint*)bp-&gt;data;<br>    <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; NINDIRECT; j++)&#123;<br>      <span class="hljs-keyword">if</span>(a[j])<br>        bfree(ip-&gt;dev, a[j]);<br>    &#125;<br>    brelse(bp);<br>    bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);<br>    ip-&gt;addrs[NDIRECT] = <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span>(ip-&gt;addrs[DINDIRECTI])&#123;<br>    bp = bread(ip-&gt;dev, ip-&gt;addrs[DINDIRECTI]);<br>    a = (uint*)bp-&gt;data;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; NINDIRECT; i++)&#123;<br>      <span class="hljs-keyword">if</span>(a[i])&#123;<br>        bp2 = bread(ip-&gt;dev, a[i]);<br>        a2 = (uint*)bp2-&gt;data;<br>        <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; NINDIRECT; j++)&#123;<br>          <span class="hljs-keyword">if</span>(a2[j])<br>            bfree(ip-&gt;dev, a2[j]);<br>        &#125;<br>        brelse(bp2);<br>        bfree(ip-&gt;dev, a[i]);<br>      &#125;<br>    &#125;<br>    brelse(bp);<br>    bfree(ip-&gt;dev, ip-&gt;addrs[DINDIRECTI]);<br>    ip-&gt;addrs[DINDIRECTI] = <span class="hljs-number">0</span>;<br>  &#125;<br><br>  ip-&gt;size = <span class="hljs-number">0</span>;<br>  iupdate(ip);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>修改<code>file.c/filewrite()</code></li></ol><p>xv6为了维持文件系统的一致性，对于文件系统的调用都将被作为一个事务来完成，由于日志大小限制，一个事务同时更新的数据块数量也受到了限制，对于大文件的写来说，将被切分成多次写，每次写几个数据块作为一个事务进行提交。</p><p>对于文件的一次写，可能需要为其分配数据块，那么存储间接块号的数据块、inode数据块都需要更新，每个事务实际使用的数据块数量应该考虑到同时更新的这些数据块；而由于添加了二级间接块号的数据块，那么同时又可能需要更新二级间接块号的数据块，因此最终每个事务使用的最大数据块又应该从每个事务的日志最大块数 -1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> max = ((MAXOPBLOCKS<span class="hljs-number">-1</span><span class="hljs-number">-2</span><span class="hljs-number">-2</span>) / <span class="hljs-number">2</span>) * BSIZE;<br></code></pre></td></tr></table></figure><h4 id="Symbolic-links"><a href="#Symbolic-links" class="headerlink" title="Symbolic links"></a>Symbolic links</h4><h5 id="任务-1"><a href="#任务-1" class="headerlink" title="任务"></a>任务</h5><p>该部分为xv6增加符号链接（软链接），符号链接通过文件路径链接另一个文件；当一个符号链接打开时，内核打开实际链接到的文件。符号链接像硬链接，但是硬链接被限制指向同一个磁盘上，符号链接可以在不同的磁盘设备上。</p><h5 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h5><ol><li>增加系统调用</li></ol><p>按照之前Lab添加系统调用的方式添加<code>symlink</code>系统调用。</p><ol start="2"><li>增加符号链接文件类型</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// stat.h</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> T_DIR     1   <span class="hljs-comment">// Directory</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> T_FILE    2   <span class="hljs-comment">// File</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> T_DEVICE  3   <span class="hljs-comment">// Device</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> T_SYMLINK 4   <span class="hljs-comment">// Symbolic link</span></span><br><br><span class="hljs-comment">// fcntl.h </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> O_RDWR    0x002</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> O_CREATE  0x200</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> O_TRUNC   0x400</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> O_NOFOLLOW 0x800 </span><br></code></pre></td></tr></table></figure><ol start="3"><li>创建<code>sysfile.c/sys_symlink()</code>系统调用函数</li></ol><p>符号链接是一个特殊的文件，文件类型为T_SYMLINK，该文件只需要存储另一个文件的路径即可，因此首先先创建一个符号链接文件，再将所链接文件路径写到符号链接文件中即可。代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">uint64</span><br><span class="hljs-function"><span class="hljs-title">sys_symlink</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">char</span> <span class="hljs-keyword">new</span>[MAXPATH], old[MAXPATH];<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">op</span>, *<span class="hljs-title">ip</span>;</span><br><br>  <span class="hljs-keyword">if</span>(argstr(<span class="hljs-number">0</span>, old, MAXPATH) &lt; <span class="hljs-number">0</span> || argstr(<span class="hljs-number">1</span>, <span class="hljs-keyword">new</span>, MAXPATH) &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>  begin_op();<br>  <span class="hljs-keyword">if</span>((op = namei(old)) != <span class="hljs-number">0</span>)&#123;<br>    ilock(op);<br>    <span class="hljs-keyword">if</span>(op-&gt;type == T_DIR)&#123;<br>      iunlockput(op);<br>      end_op();<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    iunlockput(op);<br>  &#125;<br><br>  <span class="hljs-keyword">if</span>((ip = create(<span class="hljs-keyword">new</span>, T_SYMLINK, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)) == <span class="hljs-number">0</span>)&#123;<br>    end_op();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br><br>  uint len = <span class="hljs-built_in">strlen</span>(old) + <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span>(writei(ip, <span class="hljs-number">0</span>, (uint64)old, <span class="hljs-number">0</span>, len) != len)&#123;<br>    iunlockput(ip);<br>    end_op();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br><br>  iupdate(ip);<br>  iunlockput(ip);<br>  end_op();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>修改<code>sysfile.c/sys_open()</code>增加链接文件打开方式</li></ol><p>进程使用<code>open()</code>系统调用打开符号链接文件时，可以有两种打开方式：</p><ul><li>打开模式为<code>O_NOFOLLOW</code>时，直接打开符号链接文件的内容，也即另一个文件的文件路径，直接按照一般文件打开即可</li><li>打开模式不加<code>O_NOFOLLOW</code>时，则打开所链接的文件，如果所链接的文件又是一个链接文件，这应该递归地去找到真正的文件</li></ul><p><code>sys_open()</code>函数修改如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(omode &amp; O_NOFOLLOW)&#123;<br>  <span class="hljs-keyword">if</span>((ip = namei(path)) == <span class="hljs-number">0</span>)&#123;<br>    end_op();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>&#125; <span class="hljs-keyword">else</span>&#123;<br>  <span class="hljs-keyword">char</span> rpath[MAXPATH];<br>  <span class="hljs-keyword">if</span>((ip = find_symlink(path, rpath, <span class="hljs-number">0</span>)) == <span class="hljs-number">0</span>)&#123;<br>    end_op();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>find_symlink()</code>函数递归找到真正的文件，如果递归层数过多，则停止：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">struct inode*</span><br><span class="hljs-function"><span class="hljs-title">find_symlink</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *path, <span class="hljs-keyword">char</span> *rpath, <span class="hljs-keyword">int</span> depth)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span>(depth &gt;= <span class="hljs-number">10</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">ip</span>;</span><br>  <span class="hljs-keyword">if</span>((ip = namei(path)) != <span class="hljs-number">0</span>)&#123;<br>    ilock(ip);<br><br>    <span class="hljs-keyword">if</span>(ip-&gt;type != T_SYMLINK)&#123;<br>      iunlock(ip);<br>      <span class="hljs-keyword">return</span> ip;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(readi(ip, <span class="hljs-number">0</span>, (uint64)rpath, <span class="hljs-number">0</span>, ip-&gt;size) == <span class="hljs-number">0</span>)&#123;<br>      iunlockput(ip);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    iunlockput(ip);<br>  <br>    <span class="hljs-keyword">return</span> find_symlink(rpath, rpath, depth + <span class="hljs-number">1</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="实验测试"><a href="#实验测试" class="headerlink" title="实验测试"></a>实验测试</h4><p><img src="https://whileskies-pic.oss-cn-beijing.aliyuncs.com/20210630161137.png" alt="test2"></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p><a href="https://github.com/whileskies/xv6-labs-2020/tree/fs">https://github.com/whileskies/xv6-labs-2020/tree/fs</a></p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>6.S081</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.S081-Lab8: locks</title>
    <link href="/2021/07/11/6-S081-Lab8-locks/"/>
    <url>/2021/07/11/6-S081-Lab8-locks/</url>
    
    <content type="html"><![CDATA[<h2 id="Lab8-locks"><a href="#Lab8-locks" class="headerlink" title="Lab8: locks"></a>Lab8: locks</h2><p>Lab8通过重新设计内核的一些代码，将原本粗粒度的锁更改为细粒度的锁来增加并行度。多核机器上弱并行度的一个通用的标志是具有较高的锁的争用，提高并行度通常涉及到修改数据结构和加锁策略。本实验需要重新设计xv6的memory allocator和block cache两个模块的数据结构和加锁策略，来提高并行度。</p><h4 id="Memory-allocator"><a href="#Memory-allocator" class="headerlink" title="Memory allocator"></a>Memory allocator</h4><h5 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h5><p>在原本xv6的<code>kalloc()</code>和<code>kfree()</code>的设计中，会发生较高的锁的争用，原因在于使用了一个单一的空闲物理页链表用于分配与释放物理页，该链表使用一个锁进行保护。为了移除锁的争用，需要重新设计内存分配器来避免单一的锁和链表。基本的想法是每个CPU维护一个空闲物理页链表，相应的每个链表持有一个自己的锁。在不同CPU上去分配和释放可以是并行的，因为每个CPU将操作不同的链表。其中主要的挑战是当一个CPU的链表为空时，同时另一个CPU的链表中有空闲的物理页；这种情况时，链表为空的CPU需要窃取一些其他CPU链表上的空闲物理页；窃取可能会产生锁的争用，不过还好这将不经常发生。</p><h5 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h5><ol><li>定义每个CPU一个空闲物理页链表</li></ol><p>将原本的单链表扩展为每个CPU一个链表，并在<code>kinit()</code>函数中初始化每个锁：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LOCK_NAME_N 6</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br>  <span class="hljs-keyword">char</span> lock_name[LOCK_NAME_N];<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">freelist</span>;</span><br>&#125; kmem[NCPU]<br><br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">kinit</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; NCPU; i++) &#123;<br>    <span class="hljs-built_in">snprintf</span>(kmem[i].lock_name, LOCK_NAME_N, <span class="hljs-string">&quot;kmem%d&quot;</span>, i);<br>    initlock(&amp;kmem[i].lock, kmem[i].lock_name);<br>  &#125;<br>  freerange(end, (<span class="hljs-keyword">void</span>*)PHYSTOP);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>修改<code>kalloc()</code>函数</li></ol><p>当申请物理页时，<code>kalloc()</code>被调用，由于现在每个CPU一个链表，因此需要通过<code>cpuid()</code>函数获取到当前调用<code>kalloc()</code>线程所属CPU的编号，之后从该CPU的链表中去获取一个空闲物理页；同时要注意只有中断关闭时通过<code>cpuid()</code>获取CPU号才是安全的，否则可能由于中断，之后的代码被调度到其他CPU上去执行了。</p><p>在当前CPU链表不为空时，首先对当前CPU链表加锁，并从链表中获取到空闲物理页。由于每个CPU一个锁，因此可以使得多个CPU同时调用<code>kalloc()</code>函数并分配各自链表上的空闲物理页，提高了并行度。</p><p>在当前CPU链表为空时，依次遍历其他CPU的链表，当遇到非空的CPU链表，则窃取该链表头部的空闲物理页，窃取过程中应加上被窃取CPU链表的锁。</p><p>有个细节是在窃取之前，应先释放当前CPU链表的锁，防止之后窃取过程发生死锁，所窃取的物理页之后直接作为返回值返回了，也不需要再操作当前链表。在最初的尝试中，想法是每次从其他非空的CPU链表中窃取一半的空闲物理页到当前CPU链表，但是无奈需要同时加上两个锁，会发生死锁。</p><p>修改后的<code>kalloc()</code>函数如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> *</span><br><span class="hljs-function"><span class="hljs-title">kalloc</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">r</span>;</span><br>  <br>  push_off();<br>  <span class="hljs-keyword">int</span> cpu = cpuid();<br>  acquire(&amp;kmem[cpu].lock);<br>  r = kmem[cpu].freelist;<br>  <span class="hljs-keyword">if</span>(r) &#123;<br>    kmem[cpu].freelist = r-&gt;next;<br>    release(&amp;kmem[cpu].lock);<br>  &#125;<span class="hljs-keyword">else</span> &#123;<br>    release(&amp;kmem[cpu].lock);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> nextid = <span class="hljs-number">0</span>; nextid &lt; NCPU; nextid++) &#123;<br>      <span class="hljs-keyword">if</span>(cpu != nextid) &#123;<br>        acquire(&amp;kmem[nextid].lock);<br>        r = kmem[nextid].freelist;<br>        <span class="hljs-keyword">if</span>(r) &#123;<br>          kmem[nextid].freelist = r-&gt;next;<br>          release(&amp;kmem[nextid].lock);<br>          <span class="hljs-keyword">break</span>;<br>        &#125;<br>        release(&amp;kmem[nextid].lock);<br>      &#125;<br>    &#125;<br>  &#125;<br>  pop_off();<br>  <br>  <span class="hljs-keyword">if</span>(r)<br>    <span class="hljs-built_in">memset</span>((<span class="hljs-keyword">char</span>*)r, <span class="hljs-number">5</span>, PGSIZE); <span class="hljs-comment">// fill with junk</span><br>  <span class="hljs-keyword">return</span> (<span class="hljs-keyword">void</span>*)r;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>修改<code>kfree()</code>函数</li></ol><p><code>kfree()</code>函数的修改相对简单，只要把被释放的物理页放到当前CPU链表的头部即可，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">kfree</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *pa)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">r</span>;</span><br><br>  <span class="hljs-keyword">if</span>(((uint64)pa % PGSIZE) != <span class="hljs-number">0</span> || (<span class="hljs-keyword">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)<br>    panic(<span class="hljs-string">&quot;kfree&quot;</span>);<br><br>  <span class="hljs-comment">// Fill with junk to catch dangling refs.</span><br>  <span class="hljs-built_in">memset</span>(pa, <span class="hljs-number">1</span>, PGSIZE);<br><br>  r = (struct run*)pa;<br><br>  push_off();<br>  <span class="hljs-keyword">int</span> cpu = cpuid();<br>  acquire(&amp;kmem[cpu].lock);<br>  r-&gt;next = kmem[cpu].freelist;<br>  kmem[cpu].freelist = r;<br>  release(&amp;kmem[cpu].lock);<br>  pop_off();<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h5><p><img src="https://whileskies-pic.oss-cn-beijing.aliyuncs.com/20210620172413.png" alt="image-20210620172413597"></p><h4 id="Buffer-cache"><a href="#Buffer-cache" class="headerlink" title="Buffer cache"></a>Buffer cache</h4><h5 id="任务-1"><a href="#任务-1" class="headerlink" title="任务"></a>任务</h5><p>buffer cache位于xv6文件系统中的Disk上层、Logging下层，用于缓存磁盘块，如下图所示：</p><img src="https://whileskies-pic.oss-cn-beijing.aliyuncs.com/20210620172804.png" alt="image-20210620172804214" style="zoom: 50%;" /><p>在原本的buffer cache设计中，多个buffer块用一个双向链表来组织，并通过一个锁(bcache.lock)来避免获取和释放中的race condition，通过LRU算法来淘汰buffer。</p><p>由此可见，只有一个锁，造成了大量的锁的争用，该部分的任务仍然是修改buffer cache的数据结构和加锁策略来减少争用，提高并行度。</p><p>减少buffer cache中的争用比kalloc的更为复杂，因为buffer cache是被进程（多个CPU）共享的，不能像kalloc一样每个CPU有一个自己的空闲物理页链表，每个链表上的空白物理页都是等同的，分配时不需要考虑究竟是哪个物理页，但是buffer cache中的每个buffer却是不同的。</p><p>解决办法是使用hash表，同时每个hash bucket有一个锁。</p><h5 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h5><ol><li>修改数据结构为hash表</li></ol><p>之前的buffer采用双向链表组织，为降低锁的粒度，可以使用hash表来组织，根据块号(blockno)进行hash，将buffer分布到相应的bucket中去。每个hash bucket中的buffer同样采用双向链表组织。</p><p>为了方便，每个bucket链表有一个buf作为dummy结点，用作链表头。</p><p>每个bucket有一个锁，这样获取和分配时可直接针对某个bucket进行，实现不同bucket间的并行。</p><p>同时每个buffer维护一个ticks作为时间戳，用来实现LRU算法。</p><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// kernel/buf.h</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> &#123;</span><br>  <span class="hljs-keyword">int</span> valid;   <span class="hljs-comment">// has data been read from disk?</span><br>  <span class="hljs-keyword">int</span> disk;    <span class="hljs-comment">// does disk &quot;own&quot; buf?</span><br>  uint dev;<br>  uint blockno;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sleeplock</span> <span class="hljs-title">lock</span>;</span><br>  uint refcnt;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">prev</span>;</span> <span class="hljs-comment">// LRU cache list</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">next</span>;</span><br>  uchar data[BSIZE];<br><br>  uint ticks;<br>&#125;;<br><br><span class="hljs-comment">// kernel/bio.c</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NBUCKET 13</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> <span class="hljs-title">buf</span>[<span class="hljs-title">NBUF</span>];</span><br><br>  <span class="hljs-comment">// Linked list of all buffers, through prev/next.</span><br>  <span class="hljs-comment">// Sorted by how recently the buffer was used.</span><br>  <span class="hljs-comment">// head.next is most recent, head.prev is least.</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> <span class="hljs-title">head</span>;</span><br><br>  <span class="hljs-comment">// Hash bucket</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> <span class="hljs-title">bucket</span>[<span class="hljs-title">NBUCKET</span>];</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">bucket_lock</span>[<span class="hljs-title">NBUCKET</span>];</span><br>&#125; bcache;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">hash</span><span class="hljs-params">(uint blockno)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> blockno % NBUCKET;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">binit</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">b</span>;</span><br><br>  initlock(&amp;bcache.lock, <span class="hljs-string">&quot;bcache&quot;</span>);<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; NBUCKET; i++) &#123;<br>    initlock(&amp;bcache.bucket_lock[i], <span class="hljs-string">&quot;bcache.bucket&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; NBUCKET; i++) &#123;<br>    bcache.bucket[i].next = &amp;bcache.bucket[i];<br>    bcache.bucket[i].prev = &amp;bcache.bucket[i];<br>  &#125;<br>  <br>  <span class="hljs-comment">// Create hash table of buffers</span><br>  <span class="hljs-keyword">for</span>(b = bcache.buf; b &lt; bcache.buf+NBUF; b++)&#123;<br>    <span class="hljs-keyword">int</span> i = hash(b-&gt;blockno);<br>    b-&gt;next = bcache.bucket[i].next;<br>    b-&gt;prev = &amp;bcache.bucket[i];<br><br>    bcache.bucket[i].next-&gt;prev = b;<br>    bcache.bucket[i].next = b;<br>    b-&gt;ticks = ticks;<br>    initsleeplock(&amp;b-&gt;lock, <span class="hljs-string">&quot;buffer&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>修改<code>bget()</code>函数</li></ol><p><code>bget()</code>函数可分为两步进行：</p><p>第一步：首先查找是否存在给定dev和blockno的buffer，如果存在，则使用此buffer并返回；</p><p>第二步：如果不存在，则寻找一个LRU未使用的buffer并返回。</p><p>这里面实现时有很多需要注意的细节：</p><ul><li><p>buf为共享变量，访问其中的变量时(如refcnt)需要加buf所在bucket的锁来互斥访问。</p></li><li><p><code>hi = hash(blockno)</code>，第一步应该从bucket hi中查找，如果未查找到，执行第二步，第二步从其他bucket中查找未使用buffer，并将该buffer添加到bucket hi中（如果不在同一bucket上）。</p></li><li><p>第二步可以使用一个大锁来使其串行化，如果不加有下面几种可能做法以及出现的问题：</p><ul><li>第一步中bucket hi的锁不释放：一个CPU持有bucket hi的锁，希望遍历bucket B并申请B的锁，同时另一个CPU持有bucket B锁，希望遍历bucket hi并申请hi的锁，则发生死锁；</li><li>第一步bucket hi的锁释放，第二步使用全局的LRU查找所有的bucket中未使用的buffer，两个CPU同时寻找dev和blockno相同的buffer，第一步未找到，同时寻找到了一个未使用buffer，但这两个寻找到的buffer不同，违反了<code>the invariant that at most one copy of each block is cached</code>的要求，一个块最多只能有一个buffer，会出现<code>panic: freeing free block</code>的错误；</li></ul></li><li><p>使用了大锁来使得第二步的淘汰过程串行化时，首先应在第二步开始再次寻找一遍buffer，原因是两个CPU同时寻找dev和blockno相同的buffer，第一步未找到，第一个CPU通过加锁运行第二步找到一个buffer，释放锁后第二个CPU运行第二步，此时第一个CPU已经将找到的buffer作为该dev和blockno的buffer，如果第二个CPU再次寻找一个新的buffer作为相同dev和blockno的buffer，则同样违反了<code>the invariant that at most one copy of each block is cached</code>的要求；因此在第二步应首先再次在相应的bucket hi中找一次，如果之前已经有CPU找到了该buffer，直接使用即可。</p></li><li><p>尽量避免同时加两把锁，这将有可能导致死锁。</p></li></ul><p>看网上的实现还有方式是<code>bget()</code>根据<code>hi = hash(bockno)</code>直接从bucket hi的链表中寻找，寻找不到后通过局部的LRU只从hi的链表中去寻找未使用的buffer，这样可以移除第二步的大锁，而且实现起来还挺简单，不过似乎不符合hints中的实现方式，感觉局部LRU更容易产生<code>panic(&quot;bget: no buffers&quot;);</code>。</p><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Look through buffer cache for block on device dev.</span><br><span class="hljs-comment">// If not found, allocate a buffer.</span><br><span class="hljs-comment">// In either case, return locked buffer.</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> struct buf*</span><br><span class="hljs-function"><span class="hljs-title">bget</span><span class="hljs-params">(uint dev, uint blockno)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">b</span>;</span><br>  <span class="hljs-keyword">int</span> hi = hash(blockno); <br>  <br>  <span class="hljs-comment">// Find cache from bucket hi.</span><br>  acquire(&amp;bcache.bucket_lock[hi]);<br>  <span class="hljs-keyword">for</span>(b = bcache.bucket[hi].next; b != &amp;bcache.bucket[hi]; b = b-&gt;next) &#123;<br>    <span class="hljs-keyword">if</span>(b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno) &#123;<br>      b-&gt;refcnt++;<br>      release(&amp;bcache.bucket_lock[hi]);<br>      acquiresleep(&amp;b-&gt;lock);<br>      <span class="hljs-keyword">return</span> b;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// Release lock hi, avoid deadlock.</span><br>  release(&amp;bcache.bucket_lock[hi]);<br><br>  <span class="hljs-comment">// Steal lock makes the eviction serialized in bget.</span><br>  acquire(&amp;bcache.lock);<br><br>  <span class="hljs-comment">// Check again cache to maintain the invariant that at most one copy of each block is cached. </span><br>  acquire(&amp;bcache.bucket_lock[hi]);<br>  <span class="hljs-keyword">for</span>(b = bcache.bucket[hi].next; b != &amp;bcache.bucket[hi]; b = b-&gt;next) &#123;<br>    <span class="hljs-keyword">if</span>(b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno) &#123;<br>      b-&gt;refcnt++;<br>      release(&amp;bcache.bucket_lock[hi]);<br>      release(&amp;bcache.lock);<br>      acquiresleep(&amp;b-&gt;lock);<br>      <span class="hljs-keyword">return</span> b;<br>    &#125;<br>  &#125;<br>  release(&amp;bcache.bucket_lock[hi]);<br>  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">minb</span> =</span> <span class="hljs-number">0</span>;<br>  uint min_ticks = ~<span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// Find Recycle the least recently used (LRU) unused buffer.</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; NBUCKET; i++) &#123;<br>    acquire(&amp;bcache.bucket_lock[i]);<br>    <span class="hljs-keyword">int</span> find = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(b = bcache.bucket[i].next; b != &amp;bcache.bucket[i]; b = b-&gt;next) &#123;<br>      <span class="hljs-keyword">if</span>(b-&gt;refcnt == <span class="hljs-number">0</span> &amp;&amp; b-&gt;ticks &lt; min_ticks) &#123;<br>        <span class="hljs-keyword">if</span>(minb != <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-keyword">int</span> last = hash(minb-&gt;blockno);<br>          <span class="hljs-keyword">if</span>(last != i)<br>            release(&amp;bcache.bucket_lock[last]);<br>        &#125;<br>        <br>        min_ticks = b-&gt;ticks;<br>        minb = b;<br>        find = <span class="hljs-number">1</span>;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(!find)<br>      release(&amp;bcache.bucket_lock[i]);<br>  &#125;<br><br>  <span class="hljs-keyword">if</span>(minb == <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;bget: no buffers&quot;</span>);<br>  <br>  <span class="hljs-keyword">int</span> minb_i = hash(minb-&gt;blockno);<br><br>  minb-&gt;dev = dev;<br>  minb-&gt;blockno = blockno;<br>  minb-&gt;valid = <span class="hljs-number">0</span>;<br>  minb-&gt;refcnt = <span class="hljs-number">1</span>;<br><br>  <span class="hljs-keyword">if</span> (minb_i != hi) &#123;<br>    minb-&gt;prev-&gt;next = minb-&gt;next;<br>    minb-&gt;next-&gt;prev = minb-&gt;prev;<br>  &#125;<br>  release(&amp;bcache.bucket_lock[minb_i]);<br>  <br>  <span class="hljs-keyword">if</span>(minb_i != hi) &#123;<br>    <span class="hljs-comment">// Move the buf from original bucket to bucket hi.</span><br>    acquire(&amp;bcache.bucket_lock[hi]);<br><br>    minb-&gt;next = bcache.bucket[hi].next;<br>    minb-&gt;prev = &amp;bcache.bucket[hi];<br>    bcache.bucket[hi].next-&gt;prev = minb;<br>    bcache.bucket[hi].next = minb;<br><br>    release(&amp;bcache.bucket_lock[hi]);<br>  &#125;<br><br>  release(&amp;bcache.lock);<br><br>  acquiresleep(&amp;minb-&gt;lock);<br><br>  <span class="hljs-keyword">return</span> minb;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>修改<code>brelse()</code>函数</li></ol><p><code>brelse()</code>的修改则比较简单，直接将buffer的引用数-1，如果之后未被引用的话，更新ticks，表示为最新的未使用的buffer，用于LRU算法寻找最近最少使用的unused buffer。</p><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Release a locked buffer.</span><br><span class="hljs-comment">// Move to the head of the most-recently-used list.</span><br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">brelse</span><span class="hljs-params">(struct buf *b)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span>(!holdingsleep(&amp;b-&gt;lock))<br>    panic(<span class="hljs-string">&quot;brelse&quot;</span>);<br><br>  releasesleep(&amp;b-&gt;lock);<br><br>  <span class="hljs-keyword">int</span> hi = hash(b-&gt;blockno);<br>  acquire(&amp;bcache.bucket_lock[hi]);<br>  b-&gt;refcnt--;<br>  <span class="hljs-keyword">if</span> (b-&gt;refcnt == <span class="hljs-number">0</span>) &#123;<br>    b-&gt;ticks = ticks;<br>  &#125;<br>  release(&amp;bcache.bucket_lock[hi]);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>修改<code>bpin()</code>和<code>bunpin()</code></li></ol><p>更新buffer的引用数时，应加锁，引用数为共享变量，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">bpin</span><span class="hljs-params">(struct buf *b)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> hi = hash(b-&gt;blockno);<br>  acquire(&amp;bcache.bucket_lock[hi]);<br>  b-&gt;refcnt++;<br>  release(&amp;bcache.bucket_lock[hi]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">bunpin</span><span class="hljs-params">(struct buf *b)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> hi = hash(b-&gt;blockno);<br>  acquire(&amp;bcache.bucket_lock[hi]);<br>  b-&gt;refcnt--;<br>  release(&amp;bcache.bucket_lock[hi]);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h5><p><img src="https://whileskies-pic.oss-cn-beijing.aliyuncs.com/20210622153929.png" alt="image-20210622153929205"></p><h4 id="实验测试"><a href="#实验测试" class="headerlink" title="实验测试"></a>实验测试</h4><p><img src="https://whileskies-pic.oss-cn-beijing.aliyuncs.com/20210622161745.png" alt="image-20210622161745154"></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p><a href="https://github.com/whileskies/xv6-labs-2020/tree/lock">https://github.com/whileskies/xv6-labs-2020/tree/lock</a></p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>6.S081</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.S081-Lab7: Multithreading</title>
    <link href="/2021/07/11/6-S081-Lab7-Multithreading/"/>
    <url>/2021/07/11/6-S081-Lab7-Multithreading/</url>
    
    <content type="html"><![CDATA[<h2 id="Lab7-Multithreading"><a href="#Lab7-Multithreading" class="headerlink" title="Lab7: Multithreading"></a>Lab7: Multithreading</h2><p>lab7为三个多线程相关的任务：实现用户态线程、使用多线程加速程序、实现一个线程屏障。</p><h4 id="Uthread-switching-between-threads"><a href="#Uthread-switching-between-threads" class="headerlink" title="Uthread: switching between threads"></a>Uthread: switching between threads</h4><h5 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h5><p>设计并实现一个用户态线程的上下文切换机制（其实类似于协程）。</p><h5 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h5><ol><li>定义<code>context</code>结构，用于保存上下文寄存器</li></ol><p>当从一个线程切换到另一个线程时，需要保存切换前线程的上下文，恢复切换后线程的上下文。在保存时可以参考xv6中内核线程的切换，只用保存被调用者保存的寄存器即可，因为需要调用者保存的寄存器都已经存储在线程的栈中了。</p><p>除此之外还应保存两个重要的寄存器：ra、sp，ra相当于保存了pc寄存器，用户恢复到之前切换的地方继续执行；sp保存了线程栈顶指针，每个线程都需要在栈中执行。</p><p>在<code>user/uthread.c </code>中定义<code>context</code>结构体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">context</span> &#123;</span><br>  uint64 ra;<br>  uint64 sp;<br><br>  <span class="hljs-comment">// callee-saved</span><br>  uint64 s0;<br>  uint64 s1;<br>  uint64 s2;<br>  uint64 s3;<br>  uint64 s4;<br>  uint64 s5;<br>  uint64 s6;<br>  uint64 s7;<br>  uint64 s8;<br>  uint64 s9;<br>  uint64 s10;<br>  uint64 s11;<br>&#125;;<br></code></pre></td></tr></table></figure><p>将<code>context</code>结构体添加至<code>thread</code>结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread</span> &#123;</span><br>  <span class="hljs-keyword">char</span>       <span class="hljs-built_in">stack</span>[STACK_SIZE]; <span class="hljs-comment">/* the thread&#x27;s stack */</span><br>  <span class="hljs-keyword">int</span>        state;             <span class="hljs-comment">/* FREE, RUNNING, RUNNABLE */</span><br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">context</span> <span class="hljs-title">context</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><ol start="2"><li>线程切换汇编</li></ol><p>用户线程的切换汇编代码参考了(复制了)内核线程切换的汇编代码，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c">thread_switch:<br><span class="hljs-comment">/* YOUR CODE HERE */</span><br>sd ra, <span class="hljs-number">0</span>(a0)<br>sd sp, <span class="hljs-number">8</span>(a0)<br>sd s0, <span class="hljs-number">16</span>(a0)<br>sd s1, <span class="hljs-number">24</span>(a0)<br>sd s2, <span class="hljs-number">32</span>(a0)<br>sd s3, <span class="hljs-number">40</span>(a0)<br>sd s4, <span class="hljs-number">48</span>(a0)<br>sd s5, <span class="hljs-number">56</span>(a0)<br>sd s6, <span class="hljs-number">64</span>(a0)<br>sd s7, <span class="hljs-number">72</span>(a0)<br>sd s8, <span class="hljs-number">80</span>(a0)<br>sd s9, <span class="hljs-number">88</span>(a0)<br>sd s10, <span class="hljs-number">96</span>(a0)<br>sd s11, <span class="hljs-number">104</span>(a0)<br><br>ld ra, <span class="hljs-number">0</span>(a1)<br>ld sp, <span class="hljs-number">8</span>(a1)<br>ld s0, <span class="hljs-number">16</span>(a1)<br>ld s1, <span class="hljs-number">24</span>(a1)<br>ld s2, <span class="hljs-number">32</span>(a1)<br>ld s3, <span class="hljs-number">40</span>(a1)<br>ld s4, <span class="hljs-number">48</span>(a1)<br>ld s5, <span class="hljs-number">56</span>(a1)<br>ld s6, <span class="hljs-number">64</span>(a1)<br>ld s7, <span class="hljs-number">72</span>(a1)<br>ld s8, <span class="hljs-number">80</span>(a1)<br>ld s9, <span class="hljs-number">88</span>(a1)<br>ld s10, <span class="hljs-number">96</span>(a1)<br>ld s11, <span class="hljs-number">104</span>(a1)<br>ret    <span class="hljs-comment">/* return to ra */</span><br></code></pre></td></tr></table></figure><p>声明线程切换的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">void</span> <span class="hljs-title">thread_switch</span><span class="hljs-params">(struct context*, struct context*)</span></span><br></code></pre></td></tr></table></figure><ol start="3"><li>线程初始化</li></ol><p>线程初始化时，将ra设为函数地址，sp设为该线程的堆栈，等调度到该线程时，线程就可执行所绑定的函数，需要注意栈是从高地址向低地址增长的，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> </span><br><span class="hljs-function"><span class="hljs-title">thread_create</span><span class="hljs-params">(<span class="hljs-keyword">void</span> (*func)())</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread</span> *<span class="hljs-title">t</span>;</span><br><br>  <span class="hljs-keyword">for</span> (t = all_thread; t &lt; all_thread + MAX_THREAD; t++) &#123;<br>    <span class="hljs-keyword">if</span> (t-&gt;state == FREE) <span class="hljs-keyword">break</span>;<br>  &#125;<br>  t-&gt;state = RUNNABLE;<br>  <span class="hljs-comment">// YOUR CODE HERE</span><br>  t-&gt;context.sp = (uint64)t-&gt;<span class="hljs-built_in">stack</span> + STACK_SIZE;<br>  t-&gt;context.ra = (uint64)func;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>线程切换</li></ol><p>当一个线程主动调用<code>thread_yield</code>函数时，放弃CPU的控制权，将其交给调度器，调度器函数找到下一个可执行的线程，切换到该线程进行执行，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (current_thread != next_thread) &#123;         <span class="hljs-comment">/* switch threads?  */</span><br>    next_thread-&gt;state = RUNNING;<br>    t = current_thread;<br>    current_thread = next_thread;<br>    <span class="hljs-comment">/* YOUR CODE HERE</span><br><span class="hljs-comment">     * Invoke thread_switch to switch from t to next_thread:</span><br><span class="hljs-comment">     * thread_switch(??, ??);</span><br><span class="hljs-comment">     */</span><br>    thread_switch(&amp;t-&gt;context, &amp;next_thread-&gt;context);<br>&#125; <span class="hljs-keyword">else</span><br>    next_thread = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><h5 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h5><p><img src="https://whileskies-pic.oss-cn-beijing.aliyuncs.com/20210527203130.png" alt="image-20210527203123223"></p><h4 id="Using-threads"><a href="#Using-threads" class="headerlink" title="Using threads"></a>Using threads</h4><h5 id="任务-1"><a href="#任务-1" class="headerlink" title="任务"></a>任务</h5><p>在hash表中使用多线程和锁，用于加快程序运行速度。在linux中使用<code>pthread</code>库来完成，并非xv6。</p><h5 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h5><ol><li>race condition</li></ol><p>对hash表执行插入元素的代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> </span><br><span class="hljs-function"><span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value, struct entry **p, struct entry *n)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">entry</span> *<span class="hljs-title">e</span> =</span> <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(struct entry));<br>  e-&gt;key = key;<br>  e-&gt;value = value;<br>  e-&gt;next = n;<br>  *p = e;<br>&#125;<br></code></pre></td></tr></table></figure><p>在插入元素时，首先通过对key进行hash找到相应的链表，将新插入的元素作为链表头，之前的链表接到新插入元素的后面。当单线程时肯定能正常执行，不会产生问题，但当多个线程并发的执行上面的<code>insert</code>函数时就会出现问题：两个线程同时创建新的<code>entry</code>，并将链表放到<code>entry</code>后部，之后一个线程先执行<code>*p = e</code>将自己的<code>entry</code>作为链表头，另一个线程再执行<code>*p = e</code>将自己的<code>entry</code>作为链表头，此时先执行的线程的修改被后执行的线程覆盖掉了，丢失了修改，也就没有成功插入新元素。</p><p>为解决上述多线程情况下的race condition，需要将<code>insert</code>操作作为一个原子操作，一次只能有一个线程执行，互斥锁正是用来解决此问题的。</p><ol start="2"><li>定义互斥锁</li></ol><p>定义并初始化线程互斥锁，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 全局变量</span><br><span class="hljs-keyword">pthread_mutex_t</span> lock;<br><br><span class="hljs-comment">// main函数中</span><br>pthread_mutex_init(&amp;lock, <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure><ol start="3"><li>为<code>insert</code>操作加锁</li></ol><p>在<code>put</code>函数中为<code>insert</code>函数加互斥锁，由于<code>put</code>之前基本都是读操作，不用加锁，虽然<code>e-&gt;value = value;</code>是修改操作，但不会产生冲突，一定是后修改的线程会覆盖先修改的线程，也不用加锁，只有<code>insert</code>才需要加锁，代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> </span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> i = key % NBUCKET;<br><br>  <span class="hljs-comment">// is the key already present?</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">entry</span> *<span class="hljs-title">e</span> =</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (e = table[i]; e != <span class="hljs-number">0</span>; e = e-&gt;next) &#123;<br>    <span class="hljs-keyword">if</span> (e-&gt;key == key)<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span>(e)&#123;<br>    <span class="hljs-comment">// update the existing key.</span><br>    e-&gt;value = value;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// the new is new.</span><br>    pthread_mutex_lock(&amp;lock);<br>    insert(key, value, &amp;table[i], table[i]);<br>    pthread_mutex_unlock(&amp;lock);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h5><p><img src="https://whileskies-pic.oss-cn-beijing.aliyuncs.com/20210527205109.png" alt="image-20210527205109919"></p><p>可见使用两个线程时的速度为单线程的将近2倍，并且多线程情况下没有发生插入的丢失。</p><h4 id="Barrier"><a href="#Barrier" class="headerlink" title="Barrier"></a>Barrier</h4><h5 id="任务-2"><a href="#任务-2" class="headerlink" title="任务"></a>任务</h5><p>使用<code>pthread</code>的条件等待实现线程屏障(barrier)：所有的线程都需要在该点等待直到所有其他线程也都到达了该点。</p><h5 id="过程-2"><a href="#过程-2" class="headerlink" title="过程"></a>过程</h5><p>每一轮<code>barrier</code>结构维护当前到达屏障的线程数目，当未全部达到时，先到的线程调用<code>pthread_cond_wait</code>在条件上等待，当最后一个线程到达时，再调用<code>pthread_cond_broadcast</code>唤醒所有等待的线程，之后所有线程进行新一轮的执行。</p><p>在<code>barrier()</code>函数实现的过程中，同样涉及多个线程对于<code>barrier</code>共享数据结构的修改，因此应该加锁进行同步。</p><p>代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> </span><br><span class="hljs-function"><span class="hljs-title">barrier</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  pthread_mutex_lock(&amp;bstate.barrier_mutex);<br>  bstate.nthread++;<br>  <span class="hljs-keyword">if</span> (bstate.nthread &lt; nthread) &#123;<br>    pthread_cond_wait(&amp;bstate.barrier_cond, &amp;bstate.barrier_mutex);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    pthread_cond_broadcast(&amp;bstate.barrier_cond);<br>    bstate.round++;<br>    bstate.nthread = <span class="hljs-number">0</span>;<br>  &#125;<br>  pthread_mutex_unlock(&amp;bstate.barrier_mutex);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="实验测试"><a href="#实验测试" class="headerlink" title="实验测试"></a>实验测试</h4><p><img src="https://whileskies-pic.oss-cn-beijing.aliyuncs.com/20210527210418.png" alt="image-20210527210418061"></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p><a href="https://github.com/whileskies/xv6-labs-2020/tree/thread">https://github.com/whileskies/xv6-labs-2020/tree/thread</a></p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>6.S081</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.S081-Lab6: Copy-on-Write Fork for xv6</title>
    <link href="/2021/07/11/6-S081-Lab6-Copy-on-Write-Fork-for-xv6/"/>
    <url>/2021/07/11/6-S081-Lab6-Copy-on-Write-Fork-for-xv6/</url>
    
    <content type="html"><![CDATA[<h2 id="Lab6-Copy-on-Write-Fork-for-xv6"><a href="#Lab6-Copy-on-Write-Fork-for-xv6" class="headerlink" title="Lab6: Copy-on-Write Fork for xv6"></a>Lab6: Copy-on-Write Fork for xv6</h2><p>lab6实现<code>fork()</code>的COW</p><p>虚拟内存提供一个中间层：内核通过使得页表项非法或者只读来拦截内存引用，导致页错误，继而通过改变页表项修改实际的物理地址；计算机系统领域有句名言：计算机系统的任何问题都可以通过加一个中间层来解决；lazy lab就是一个例子，该实验实现了另一个例子：写时复制fork</p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>xv6中的<code>fork()</code>系统调用会拷贝父进程的用户内存空间到子进程；如果父进程非常大，拷贝可能会消耗很长时间，甚至，拷贝过程通常产生大的浪费，比如<code>fork()</code>调用通常会伴随着子进程调用<code>exec()</code>并清除掉所拷贝的内存，很可能根本就没有使用过这些内存；另一方面，如果父进程与子进程共享相同的物理页，当其中一个希望写该物理页时，需要拷贝该物理页</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>写时复制(COW) <code>fork()</code>的目标是推迟分配和拷贝物理页直到真正实际需要拷贝时</p><p><code>COW fork()</code>仅仅为子进程创建页表，并且使得页表项中的用户地址指向父进程相应的物理页；<code>COW fork()</code>标记父子进程的页表项均为只读的（不可写的）；当有一方尝试写这些COW页时，CPU会产生页错误；内核页错误处理程序处理页错误，为出错进程分配物理页，复制原始页数据到新的物理页，修改相应页表项指向新物理页，这时将相应页表项标记为可写的；当页错误处理程序返回，用户进程可以正常写所复制的页</p><p><code>COW fork()</code>释放物理页时有些棘手，一个物理页可能会被多个进程的页表所引用，应该当最后一个引用取消时才能释放</p><h4 id="Implement-copy-on-write-hard"><a href="#Implement-copy-on-write-hard" class="headerlink" title="Implement copy-on write(hard)"></a>Implement copy-on write(hard)</h4><h5 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h5><p>完成写时复制<code>fork()</code>，修改后能够通过<code>cowtest</code>和<code>usertests</code></p><h5 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h5><ol><li>引用计数实现</li></ol><p>由上所述，COW时一个物理页可能会被多个进程的页表引用，如一个进程调用<code>fork()</code>，子进程再次调用<code>fork()</code>…，那么只有没有进程引用该物理页时该物理页才能被释放，可以使用引用计数解决，每个物理页对应一个数值，表示当前被引用的进程个数，当个数为0时释放</p><p>实现时可以维护一个引用计数数组，数组的第<code>i</code>项表示从<code>KERNBASE</code>开始的第<code>i</code>个物理页的引用计数，最大物理页的个数为<code>(PHYSTOP - KERNBASE) / PGSIZE</code>，在<code>kalloc.c</code>中定义引用数组，由于是全局变量，初始值均为0：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">uint16 pgs_rfc[(PHYSTOP - KERNBASE) / PGSIZE];<br></code></pre></td></tr></table></figure><p>给出一个物理地址<code>get_pg_rfc()</code>函数获取相应物理页的引用计数，<code>set_pg_rfc()</code>设置物理页的引用计数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">uint16</span><br><span class="hljs-function"><span class="hljs-title">get_pg_rfc</span><span class="hljs-params">(uint64 pa)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> pgs_rfc[(pa - KERNBASE) &gt;&gt; <span class="hljs-number">12</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">set_pg_rfc</span><span class="hljs-params">(uint64 pa, uint16 rfc)</span></span><br><span class="hljs-function"></span>&#123;<br>  pgs_rfc[(pa - KERNBASE) &gt;&gt; <span class="hljs-number">12</span>] = rfc;<br>&#125;<br></code></pre></td></tr></table></figure><p>修改<code>kalloc.c/kfree()</code>，仅当pa对应的物理页引用计数 &lt;= 1时，才释放物理页，当超过一个进程引用物理页时，仅仅将引用数 -1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(((uint64)pa % PGSIZE) != <span class="hljs-number">0</span> || (<span class="hljs-keyword">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)<br>  panic(<span class="hljs-string">&quot;kfree&quot;</span>);<br><br>uint16 ref = get_pg_rfc((uint64)pa);<br><span class="hljs-keyword">if</span> (ref &gt; <span class="hljs-number">1</span>) &#123;<br>  set_pg_rfc((uint64)pa, ref - <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>修改<code>kalloc.c/kalloc</code>，当分配一个物理页时，该物理页的引用计数为1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(r) &#123;<br>  <span class="hljs-built_in">memset</span>((<span class="hljs-keyword">char</span>*)r, <span class="hljs-number">5</span>, PGSIZE); <span class="hljs-comment">// fill with junk</span><br>  set_pg_rfc((uint64)r, <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>修改<code>vm.c/uvmcopy</code>函数为COW</li></ol><p><code>fork()</code>函数通过调用<code>uvmcopy()</code>函数复制父进程的所有物理页，因此需要将其修改为父子进程共享同一物理页，并且相应的页表项均为只读与使用COW标记，同时物理页的引用计数+1</p><p>页表项COW标记在PTE的第8位（RSW预留位）设置，在<code>riscv.h</code>中添加如下宏定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PTE_COW (1L &lt;&lt; 8)</span><br></code></pre></td></tr></table></figure><p>修改后的<code>uvmcopy</code>函数代码为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">uvmcopy</span><span class="hljs-params">(<span class="hljs-keyword">pagetable_t</span> old, <span class="hljs-keyword">pagetable_t</span> <span class="hljs-keyword">new</span>, uint64 sz)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">pte_t</span> *pte;<br>  uint64 pa, i;<br>  uint flags;<br><br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; sz; i += PGSIZE)&#123;<br>    <span class="hljs-keyword">if</span>((pte = walk(old, i, <span class="hljs-number">0</span>)) == <span class="hljs-number">0</span>)<br>      panic(<span class="hljs-string">&quot;uvmcopy: pte should exist&quot;</span>);<br>    <span class="hljs-keyword">if</span>((*pte &amp; PTE_V) == <span class="hljs-number">0</span>)<br>      panic(<span class="hljs-string">&quot;uvmcopy: page not present&quot;</span>);<br>    pa = PTE2PA(*pte);<br>    flags = PTE_FLAGS(*pte);<br><br>    *pte = *pte &amp; ~PTE_W;<br>    *pte = *pte | PTE_COW;<br>    set_pg_rfc(pa, get_pg_rfc(pa) + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span>(mappages(<span class="hljs-keyword">new</span>, i, PGSIZE, pa, (flags &amp; ~PTE_W) | PTE_COW) != <span class="hljs-number">0</span>) &#123;<br>      set_pg_rfc(pa, get_pg_rfc(pa) - <span class="hljs-number">1</span>);<br>      <span class="hljs-keyword">goto</span> err;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br> err:<br>  uvmunmap(<span class="hljs-keyword">new</span>, <span class="hljs-number">0</span>, i / PGSIZE, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li><code>cow()</code>写时复制函数实现</li></ol><p>当<code>COW fork()</code>后，父进程或子进程写被共享的物理页时，需要分配一新物理页，复制被共享的物理页，新物理页对应的页表项标记位可写，被共享物理页引用计数 -1，当引用计数为0时，释放被共享物理页</p><p>在<code>vm.c</code>中添加<code>cow()</code>函数，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">cow</span><span class="hljs-params">(uint64 va, struct proc *p)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">pte_t</span> *pte = walk(p-&gt;pagetable, va, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span>(*pte &amp; PTE_COW) &#123;<br>    <span class="hljs-keyword">char</span> *mem;<br>    uint64 pa = PTE2PA(*pte);<br><br>    <span class="hljs-keyword">if</span>((mem = kalloc()) == <span class="hljs-number">0</span>) <br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>    memmove(mem, (<span class="hljs-keyword">char</span>*)pa, PGSIZE);<br>    uint16 rfc = get_pg_rfc(pa);<br>    rfc--;<br>    set_pg_rfc(pa, rfc);<br>    <span class="hljs-keyword">if</span> (rfc == <span class="hljs-number">0</span>) &#123;<br>      kfree((<span class="hljs-keyword">char</span> *)pa);<br>    &#125;<br><br>    <span class="hljs-keyword">pte_t</span> newpte = PA2PTE(mem);<br>    newpte = ((newpte | PTE_FLAGS(*pte)) | PTE_W) &amp; ~PTE_COW;<br>    *pte = newpte;<br>  &#125; <span class="hljs-keyword">else</span> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-2</span>;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>调用<code>cow()</code></li></ol><p>当父进程或子进程写入数据到只读的共享页时，发生页错误，<code>trap.c/usertrap()</code>函数处理该页错误，当错误码为15时，执行COW，也即<code>cow()</code>函数，trap返回后会写入到合法的物理页，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((which_dev = devintr()) != <span class="hljs-number">0</span>)&#123;<br>  <span class="hljs-comment">// ok</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(r_scause() == <span class="hljs-number">15</span>) &#123;<br>  uint64 stval = r_stval();<br>  <span class="hljs-keyword">if</span> (cow(stval, p) != <span class="hljs-number">0</span>) &#123;<br>    p-&gt;killed = <span class="hljs-number">1</span>;<br>  &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br></code></pre></td></tr></table></figure><p>当父进程或子进程调用如<code>read()</code>之类的系统调用，将内核数据写入用户地址空间，如果该地址实际的物理页为共享页的话，也会发生错误，但是出错时内核正在执行系统调用，不会产生<code>usertrap</code>，因此需要在<code>vm.c/copyout()</code>中增加COW的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">copyout</span><span class="hljs-params">(<span class="hljs-keyword">pagetable_t</span> pagetable, uint64 dstva, <span class="hljs-keyword">char</span> *src, uint64 len)</span></span><br><span class="hljs-function"></span>&#123;<br>  uint64 n, va0, pa0;<br><br>  <span class="hljs-keyword">while</span>(len &gt; <span class="hljs-number">0</span>)&#123;<br>    va0 = PGROUNDDOWN(dstva);<br>    pa0 = walkaddr(pagetable, va0);<br>    <span class="hljs-keyword">if</span>(pa0 == <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    cow(va0, myproc());<br>    pa0 = walkaddr(pagetable, va0);<br><br>    n = PGSIZE - (dstva - va0);<br>    <span class="hljs-keyword">if</span>(n &gt; len)<br>      n = len;<br>    memmove((<span class="hljs-keyword">void</span> *)(pa0 + (dstva - va0)), src, n);<br><br>    len -= n;<br>    src += n;<br>    dstva = va0 + PGSIZE;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li>修改引用计数时加锁</li></ol><p>当修改某物理页引用计数时分为两步：<code>set_pg_rfc(pa, get_pg_rfc(pa) + 1)</code>，首先通过<code>get_pg_rfc()</code>函数获取某物理页的引用计数，之后再通过<code>set_pg_rfc()</code>来修改引用计数，当多个进程同时修改同一物理页的引用计数时，会发生<code>race conditons</code>，如果不加锁，会造成物理页的内存泄露</p><p>举个例子，如果有3个进程共享同一物理页，那么该物理页的引用计数为3，当其中2个进程同时调用<code>kfree()</code>函数释放物理页，在<code>kfree()</code>代码中，2个进程同时执行<code>uint16 ref = get_pg_rfc((uint64)pa)</code>，得到当前引用计数为3，之后一个进程先执行<code>set_pg_rfc((uint64)pa, ref - 1)</code>将该页引用计数变为2，再之后另一个进程同样执行<code>set_pg_rfc((uint64)pa, ref - 1)</code>将该页引用计数变为2，这样最终该页引用计数变为2（正确情况应为1），丢失了一次更新，实际上之后只有1个进程共享该物理页，当该进程也调用<code>kfree()</code>释放物理页时，引用计数从2变为1，而不是直接释放该物理页，最终造成该物理页的泄露，一直不会被回收</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">kfree</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *pa)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">r</span>;</span><br>  <span class="hljs-keyword">if</span>(((uint64)pa % PGSIZE) != <span class="hljs-number">0</span> || (<span class="hljs-keyword">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)<br>    panic(<span class="hljs-string">&quot;kfree&quot;</span>);<br><br>  acquire(&amp;rfc_lock);<br>  uint16 ref = get_pg_rfc((uint64)pa);<br>  <span class="hljs-keyword">if</span> (ref &gt; <span class="hljs-number">1</span>) &#123;<br>    set_pg_rfc((uint64)pa, ref - <span class="hljs-number">1</span>);<br>    release(&amp;rfc_lock);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  release(&amp;rfc_lock);<br><br>  <span class="hljs-comment">// Fill with junk to catch dangling refs.</span><br>  <span class="hljs-built_in">memset</span>(pa, <span class="hljs-number">1</span>, PGSIZE);<br>  r = (struct run*)pa;<br>  acquire(&amp;kmem.lock);<br>  r-&gt;next = kmem.freelist;<br>  kmem.freelist = r;<br>  release(&amp;kmem.lock);<br>&#125;<br></code></pre></td></tr></table></figure><p>因此，为解决并发出现的问题，应当把获取引用计数、修改引用计数这两步操作作为一个原子操作，一次只能有一个CPU或进程执行该临界区代码</p><p>首先在<code>kalloc.c</code>定义页引用的自旋锁：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">rfc_lock</span>;</span><br></code></pre></td></tr></table></figure><p>在<code>kalloc.c/kinit()</code>函数中初始化该自旋锁：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">kinit()<br>&#123;<br>  initlock(&amp;kmem.lock, <span class="hljs-string">&quot;kmem&quot;</span>);<br>  initlock(&amp;rfc_lock, <span class="hljs-string">&quot;pgs_rfc&quot;</span>);<br>  freerange(end, (<span class="hljs-keyword">void</span>*)PHYSTOP);<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>kalloc.c/kfree()</code>函数中加锁：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">acquire(&amp;rfc_lock);<br>uint16 ref = get_pg_rfc((uint64)pa);<br><span class="hljs-keyword">if</span> (ref &gt; <span class="hljs-number">1</span>) &#123;<br>  set_pg_rfc((uint64)pa, ref - <span class="hljs-number">1</span>);<br>  release(&amp;rfc_lock);<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br>release(&amp;rfc_lock);<br></code></pre></td></tr></table></figure><p>在<code>vm.c/uvmcopy()</code>函数中加锁：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">acquire(&amp;rfc_lock);<br>set_pg_rfc(pa, get_pg_rfc(pa) + <span class="hljs-number">1</span>);<br>release(&amp;rfc_lock);<br><span class="hljs-keyword">if</span>(mappages(<span class="hljs-keyword">new</span>, i, PGSIZE, pa, (flags &amp; ~PTE_W) | PTE_COW) != <span class="hljs-number">0</span>) &#123;<br>  acquire(&amp;rfc_lock);<br>  set_pg_rfc(pa, get_pg_rfc(pa) - <span class="hljs-number">1</span>);<br>  release(&amp;rfc_lock);<br>  <span class="hljs-keyword">goto</span> err;<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>vm.c/cow</code>中加锁：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">acquire(&amp;rfc_lock);<br>uint16 rfc = get_pg_rfc(pa);<br>rfc--;<br>set_pg_rfc(pa, rfc);<br>release(&amp;rfc_lock);<br><span class="hljs-keyword">if</span> (rfc == <span class="hljs-number">0</span>) &#123;<br>  kfree((<span class="hljs-keyword">char</span> *)pa);<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上这里加锁的粒度比较大，是对访问整个引用数组时加锁，实际上只需对访问特定物理页的引用计数时加锁，但是这样需要的锁过多</p><h4 id="实验测试"><a href="#实验测试" class="headerlink" title="实验测试"></a>实验测试</h4><p><img src="https://whileskies-pic.oss-cn-beijing.aliyuncs.com/20210413175049.png" alt="image-20210413175042082"></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p><a href="https://github.com/whileskies/xv6-labs-2020/tree/cow">https://github.com/whileskies/xv6-labs-2020/tree/cow</a></p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>6.S081</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.S081-Lab5: xv6 lazy page allocation</title>
    <link href="/2021/07/11/6-S081-Lab5-xv6-lazy-page-allocation/"/>
    <url>/2021/07/11/6-S081-Lab5-xv6-lazy-page-allocation/</url>
    
    <content type="html"><![CDATA[<h2 id="Lab5-xv6-lazy-page-allocation"><a href="#Lab5-xv6-lazy-page-allocation" class="headerlink" title="Lab5: xv6 lazy page allocation"></a>Lab5: xv6 lazy page allocation</h2><p>lab5主要是为sbrk()系统调用实现懒分配</p><p>os可以使用页表实现很多技巧，其中一个是对于用户空间堆内存的懒分配，xv6应用程序使用sbrk()系统调用来向内核申请堆内存；在未修改版本的xv6中，sbrk()分配物理页，并将其映射到进程的虚拟地址空间，对一个大的堆内存申请需求，内核需要一段时间去分配并且映射到页表；另外，一些程序会申请比实际使用更多的内存，或者在使用前去分配内存；为了使得sbrk()在这些情况下更快完成，更为复杂的内核实现懒分配；这时，sbrk()不实际分配物理内存，而是记录哪些用户地址被分配，并且在用户页表标记这些地址是非法的；当进程首次尝试访问懒分配的内存中任何一页时，CPU会产生页错误，内核处理该错误，为其分配物理内存，填充0，并且进行映射；在该lab中为xv6添加该特性</p><h4 id="Eliminate-allocation-from-sbrk-easy"><a href="#Eliminate-allocation-from-sbrk-easy" class="headerlink" title="Eliminate allocation from sbrk() (easy)"></a>Eliminate allocation from sbrk() (easy)</h4><h5 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h5><p>完成lazy alloc首先需要在sbrk(n)系统调用实现中删除物理页分配代码，sbrk(n)系统调用增长进程n个字节的内存大小，返回新分配区域的首地址；新的sbrk(n)应该仅仅增加进程n个字节的内存大小，并返回之前的内存边界；由于不分配物理内存，所以需要删除growproc()函数</p><h5 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h5><p>修改<code>sysproc.c/sys_sbrk</code>的实现，仅仅修改进程的sz的值，而不实际分配物理页，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">uint64</span><br><span class="hljs-function"><span class="hljs-title">sys_sbrk</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> addr;<br>  <span class="hljs-keyword">int</span> n;<br><br>  <span class="hljs-keyword">if</span>(argint(<span class="hljs-number">0</span>, &amp;n) &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span>* <span class="hljs-title">p</span> =</span> myproc();<br>  addr = p-&gt;sz;<br>  <br>  <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">0</span>) &#123;<br>    uvmdealloc(p-&gt;pagetable, p-&gt;sz, p-&gt;sz + n);<br>  &#125;<br>  p-&gt;sz += n;<br>  <br>  <span class="hljs-keyword">return</span> addr;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Lazy-allocation-moderate"><a href="#Lazy-allocation-moderate" class="headerlink" title="Lazy allocation (moderate)"></a>Lazy allocation (moderate)</h4><h5 id="任务-1"><a href="#任务-1" class="headerlink" title="任务"></a>任务</h5><p>修改<code>trap.c</code>中的代码使得当用户地址发生页错误时，为页错误地址分配新的物理页，并进行映射</p><h5 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h5><ol><li>创建<code>vm.c/lazy_alloc</code>函数</li></ol><p><code>lazy_alloc</code>函数根据出现页错误时的进程虚拟地址，为该进程分配物理页并进行映射</p><p>如果进程访问的虚拟地址超出进程内存大小（堆空间）边界或低于栈顶地址时，杀掉此进程</p><p>当分配物理页失败或映射物理页到用户页表失败时，同样杀掉此进程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Lazy alloc for sbrk</span><br><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">lazy_alloc</span><span class="hljs-params">(uint64 stval, struct proc *p)</span></span><br><span class="hljs-function"></span>&#123;<br>  uint64 va = PGROUNDDOWN(stval);<br>  <span class="hljs-keyword">if</span>(stval &gt;= p-&gt;sz || stval &lt; PGROUNDDOWN(p-&gt;trapframe-&gt;sp)) &#123;<br>    <span class="hljs-comment">//printf(&quot;lazy alloc error: va higher than sz or below user stack\n&quot;);</span><br>    p-&gt;killed = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">char</span> *mem = kalloc();<br>  <span class="hljs-keyword">if</span>(mem == <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-comment">//printf(&quot;lazy alloc error: no more memory\n&quot;);</span><br>    p-&gt;killed = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br><br>  <span class="hljs-built_in">memset</span>(mem, <span class="hljs-number">0</span>, PGSIZE);<br>  <span class="hljs-keyword">if</span>(mappages(p-&gt;pagetable, va, PGSIZE, (uint64)mem, PTE_W|PTE_R|PTE_U) != <span class="hljs-number">0</span>)&#123;<br>    kfree(mem);<br>    <span class="hljs-comment">//printf(&quot;lazy alloc error: map error\n&quot;);</span><br>    p-&gt;killed = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>处理页错误陷入</li></ol><p>当用户进程访问到某个堆空间处的虚拟地址，由于是懒分配，实际上并没有分配相应的物理页，cpu产生缺页中断，产生页错误陷入到内核后，应调用<code>lazy_alloc</code>为其分配物理页后，重新访问该地址</p><p>陷入的原因状态码被保存在<code>scause</code>寄存器中，13代表Load page fault、15代表Store page fault，因此当<code>scause</code>为13或15时，也即进程正在读取或写入虚拟地址时，实现懒分配并恢复访问</p><p>代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((which_dev = devintr()) != <span class="hljs-number">0</span>)&#123;<br>  <span class="hljs-comment">// ok</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (r_scause() == <span class="hljs-number">13</span> || r_scause() == <span class="hljs-number">15</span>) &#123;<br>  <span class="hljs-comment">// lazy allocation</span><br>  <span class="hljs-comment">// printf(&quot;page fault: stval=%p pid=%d\n&quot;, r_stval(), p-&gt;pid);</span><br>  uint64 stval = r_stval();<br>  lazy_alloc(stval, p);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br></code></pre></td></tr></table></figure><ol start="3"><li>修改<code>vm.c/uvmunmap</code>函数</li></ol><p>由于是懒分配，当进程需要被释放，取消映射的页表时，有的物理页实际并不存在，因此需要修改取消映射的规则，当物理页不存在时略过</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(a = va; a &lt; va + npages*PGSIZE; a += PGSIZE)&#123;<br>  <span class="hljs-keyword">if</span>((pte = walk(pagetable, a, <span class="hljs-number">0</span>)) == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-comment">//panic(&quot;uvmunmap: walk&quot;);</span><br>  <span class="hljs-keyword">if</span>((*pte &amp; PTE_V) == <span class="hljs-number">0</span>)<br>    <span class="hljs-comment">//panic(&quot;uvmunmap: not mapped&quot;);</span><br>    <span class="hljs-keyword">continue</span>;<br>  <span class="hljs-keyword">if</span>(PTE_FLAGS(*pte) == PTE_V)<br>    panic(<span class="hljs-string">&quot;uvmunmap: not a leaf&quot;</span>);<br>  <span class="hljs-keyword">if</span>(do_free)&#123;<br>    uint64 pa = PTE2PA(*pte);<br>    kfree((<span class="hljs-keyword">void</span>*)pa);<br>  &#125;<br>  *pte = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Lazytests-and-Usertests-moderate"><a href="#Lazytests-and-Usertests-moderate" class="headerlink" title="Lazytests and Usertests (moderate)"></a>Lazytests and Usertests (moderate)</h4><h5 id="任务-2"><a href="#任务-2" class="headerlink" title="任务"></a>任务</h5><p>使得将内核修改为lazy alloc后能够通过<code>lazytests</code>和<code>usertests</code></p><h5 id="过程-2"><a href="#过程-2" class="headerlink" title="过程"></a>过程</h5><ol><li>修改<code>vm.c/uvmcopy</code></li></ol><p>由于<code>fork</code>系统调用需要复制父进程的地址空间到子进程，父进程的一些地址空间的物理页并没有被分配，因此复制时应跳过不存在的物理页，不进行复制</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>((pte = walk(old, i, <span class="hljs-number">0</span>)) == <span class="hljs-number">0</span>)<br>  <span class="hljs-keyword">continue</span>;<br>  <span class="hljs-comment">//panic(&quot;uvmcopy: pte should exist&quot;);</span><br><span class="hljs-keyword">if</span>((*pte &amp; PTE_V) == <span class="hljs-number">0</span>)<br>  <span class="hljs-keyword">continue</span>;<br>  <span class="hljs-comment">//panic(&quot;uvmcopy: page not present&quot;);</span><br>pa = PTE2PA(*pte);<br>flags = PTE_FLAGS(*pte);<br></code></pre></td></tr></table></figure><ol start="2"><li>处理当进程调用如<code>read</code>、<code>write</code>系统调用时传递合法的虚拟地址参数，但该地址实际的物理页未分配的情况</li></ol><p><code>read</code>系统调用需要传递一个用户的虚拟地址指针，内核将文件数据复制到该用户指针指向的虚拟地址处，该地址如果是堆内存空间的地址，当所对应的物理页并没有分配时，会在<code>read</code>系统调用过程中出现错误，但不同于用户进程访问未分配内存的地址时出现的页错误；该错误应在<code>read</code>中处理，提前判断进程传进的用户指针参数所对应的物理页是否存在，如果不存在则分配；<code>write</code>、<code>pipe</code>系统调用也是类似的</p><p>当用户指针参数<code>p</code>不合法时，应对<code>read</code>返回表示错误的返回值，而不是杀掉该进程，因此应修改上述的<code>vm.c/lazy_alloc</code>代码为<code>vm.c/lazy_wr_alloc</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Lazy alloc for write read and pipe</span><br><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">lazy_wr_alloc</span><span class="hljs-params">(uint64 va, struct proc *p)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span>(va &gt;= p-&gt;sz || va &lt; PGROUNDDOWN(p-&gt;trapframe-&gt;sp)) &#123;<br>    <span class="hljs-comment">//printf(&quot;lazy wr alloc error: va higher than sz\n&quot;);</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">char</span> *mem = kalloc();<br>  <span class="hljs-keyword">if</span>(mem == <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-comment">//printf(&quot;lazy wr alloc error: no more memory\n&quot;);</span><br>    p-&gt;killed = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br><br>  <span class="hljs-built_in">memset</span>(mem, <span class="hljs-number">0</span>, PGSIZE);<br>  <span class="hljs-keyword">if</span>(mappages(p-&gt;pagetable, va, PGSIZE, (uint64)mem, PTE_W|PTE_R|PTE_U) != <span class="hljs-number">0</span>)&#123;<br>    kfree(mem);<br>    <span class="hljs-comment">//printf(&quot;lazy wr alloc error: map error\n&quot;);</span><br>    p-&gt;killed = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>sysfile.c/sys_read</code>修改如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">uint64</span><br><span class="hljs-function"><span class="hljs-title">sys_read</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">f</span>;</span><br>  <span class="hljs-keyword">int</span> n;<br>  uint64 p;<br><br>  <span class="hljs-keyword">if</span>(argfd(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, &amp;f) &lt; <span class="hljs-number">0</span> || argint(<span class="hljs-number">2</span>, &amp;n) &lt; <span class="hljs-number">0</span> || argaddr(<span class="hljs-number">1</span>, &amp;p) &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">pro</span> =</span> myproc();<br>  <span class="hljs-keyword">for</span>(uint64 va = PGROUNDDOWN(p); va &lt; p + n; va += PGSIZE) &#123;<br>    <span class="hljs-keyword">if</span>(walkaddr(pro-&gt;pagetable, va) == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">if</span>(lazy_wr_alloc(va, pro) &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> fileread(f, p, n);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>sysfile.c/sys_write</code>修改如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">uint64</span><br><span class="hljs-function"><span class="hljs-title">sys_write</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">f</span>;</span><br>  <span class="hljs-keyword">int</span> n;<br>  uint64 p;<br><br>  <span class="hljs-keyword">if</span>(argfd(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, &amp;f) &lt; <span class="hljs-number">0</span> || argint(<span class="hljs-number">2</span>, &amp;n) &lt; <span class="hljs-number">0</span> || argaddr(<span class="hljs-number">1</span>, &amp;p) &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">pro</span> =</span> myproc();<br>  <span class="hljs-keyword">for</span>(uint64 va = PGROUNDDOWN(p); va &lt; p + n; va += PGSIZE) &#123;<br>    <span class="hljs-keyword">if</span>(walkaddr(pro-&gt;pagetable, va) == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">if</span>(lazy_wr_alloc(va, pro) &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> filewrite(f, p, n);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>sysfile.c/sys_pipe</code>修改如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(argaddr(<span class="hljs-number">0</span>, &amp;fdarray) &lt; <span class="hljs-number">0</span>)<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br><span class="hljs-keyword">for</span>(uint64 va = PGROUNDDOWN(fdarray); va &lt; PGROUNDUP(fdarray + <span class="hljs-number">2</span>*<span class="hljs-keyword">sizeof</span>(fd0)); va += PGSIZE) &#123;<br>  <span class="hljs-keyword">if</span>(walkaddr(p-&gt;pagetable, va) == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">if</span>(lazy_wr_alloc(va, p) &lt; <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">if</span>(pipealloc(&amp;rf, &amp;wf) &lt; <span class="hljs-number">0</span>)<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br></code></pre></td></tr></table></figure><h5 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h5><p>lazytests:</p><p><img src="https://whileskies-pic.oss-cn-beijing.aliyuncs.com/20210410160218.png" alt="image-20210410160211604"></p><p>usertests:</p><p><img src="https://whileskies-pic.oss-cn-beijing.aliyuncs.com/20210410164834.png" alt="image-20210410164834879"></p><h4 id="实验测试"><a href="#实验测试" class="headerlink" title="实验测试"></a>实验测试</h4><p><img src="https://whileskies-pic.oss-cn-beijing.aliyuncs.com/20210410164038.png" alt="image-20210410164038207"></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p><a href="https://github.com/whileskies/xv6-labs-2020/tree/lazy">https://github.com/whileskies/xv6-labs-2020/tree/lazy</a></p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>6.S081</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.S081-Lab4: traps</title>
    <link href="/2021/07/11/6-S081-Lab4-traps/"/>
    <url>/2021/07/11/6-S081-Lab4-traps/</url>
    
    <content type="html"><![CDATA[<h2 id="Lab4-traps"><a href="#Lab4-traps" class="headerlink" title="Lab4: traps"></a>Lab4: traps</h2><p>Lab4为函数调用以及陷入相关的实验</p><h4 id="RISC-V-assembly-easy"><a href="#RISC-V-assembly-easy" class="headerlink" title="RISC-V assembly (easy)"></a>RISC-V assembly (easy)</h4><p>该部分为一系列RISC-V汇编相关的问题，阅读<code>user/call.asm</code>对应的<code>call.asm</code>汇编文件，回答下面问题：</p><ol><li>哪些寄存器包含函数的参数，例如，对于<code>main</code>调用<code>printf</code>函数，哪个寄存器存参数13？</li></ol><p>对于RISC-V，前8个参数会放置在a0-a7寄存器，a2放置参数13，如下代码所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs assembly">void main(void) &#123;<br>  1c:1101                addisp,sp,-32<br>  1e:ec06                sdra,24(sp)<br>  20:e822                sds0,16(sp)<br>  22:1000                addis0,sp,32<br>  printf(&quot;%d %d\n&quot;, f(8)+1, 13);<br>  24:4635                lia2,13<br>  26:45b1                lia1,12<br>  28:00000517          auipca0,0x0<br>  2c:7f850513          addia0,a0,2040 # 820 &lt;malloc+0xea&gt;<br>  30:00000097          auipcra,0x0<br>  34:648080e7          jalr1608(ra) # 678 &lt;printf&gt;<br><br></code></pre></td></tr></table></figure><ol start="2"><li><code>main</code>汇编中哪里调用了函数<code>f</code>和<code>g</code>？</li></ol><p>由上述代码可以看到，<code>main</code>中直接得到了12，并放到了a1寄存器，可见编译器进行了优化，直接得到了结果</p><ol start="3"><li><code>printf</code>的地址在哪？</li></ol><p>由汇编文件可以看到<code>printf</code>的地址为0x630，当做完alarm后，该汇编文件会发生变化，<code>printf</code>的地址也会变化</p><ol start="4"><li>当要进入<code>main</code>中<code>printf</code>函数，执行<code>jalr</code>指令后ra寄存器的值是多少？</li></ol><p>ra应为函数调用中断点出的地址，也即<code>jalr</code>下一条指令的地址，为0x38</p><ol start="5"><li>运行下列代码：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0x00646c72</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;H%x Wo%s&quot;</span>, <span class="hljs-number">57616</span>, &amp;i);<br></code></pre></td></tr></table></figure><p>输出依赖于RISC-V是小端系统，如果RISC-V是大端，i应如何设置得到相同结果，是否需要改变57616的值？</p><p>小端即低字节放置在低地址，输出为：”HE110 World”，如果为大端i为0x726c6400，57616不需要改变</p><ol start="6"><li>下列代码：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;x=%d y=%d&quot;</span>, <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><p><code>y=</code>将要输出什么，为什么会这样？</p><p>输出结果为x=3，但y是一个不确定的值，实际可能为a2寄存器的值</p><h4 id="Backtrace-moderate"><a href="#Backtrace-moderate" class="headerlink" title="Backtrace (moderate)"></a>Backtrace (moderate)</h4><h5 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h5><p>在<code>kernel/printf.c</code>实现<code>backtrace()</code>函数，用于打印函数调用过程，在<code>sys_sleep</code>中插入该函数，之后运行测试</p><h5 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h5><ol><li>内联汇编读取s0寄存器，即fp栈指针的值</li></ol><p>代码如下所示，fp(s0)寄存器用于保存当前函数栈帧的首地址：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> uint64</span><br><span class="hljs-function"><span class="hljs-title">r_fp</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  uint64 x;<br>  <span class="hljs-function"><span class="hljs-keyword">asm</span> <span class="hljs-title">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;mv %0, s0&quot;</span> : <span class="hljs-string">&quot;=r&quot;</span> (x) )</span></span>;<br>  <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>栈帧结构</li></ol><p>如下所示，fp寄存器为当前栈帧的首地址，fp-8为上级函数的返回地址，fp-16为上级栈帧的首地址，一直沿着上级栈帧的地址，可以打印出整个栈的调用过程</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">Stack<br>                   .<br>                   .<br>      +-&gt;          .<br>      |<span class="hljs-string">   +-----------------+   </span>|<br>      |<span class="hljs-string">   </span>|<span class="hljs-string"> return address  </span>|<span class="hljs-string">   </span>|<br>      |<span class="hljs-string">   </span>|<span class="hljs-string">   previous fp ------+</span><br><span class="hljs-string">      </span>|<span class="hljs-string">   </span>|<span class="hljs-string"> saved registers </span>|<br>      |<span class="hljs-string">   </span>|<span class="hljs-string"> local variables </span>|<br>      |<span class="hljs-string">   </span>|<span class="hljs-string">       ...       </span>|<span class="hljs-string"> &lt;-+</span><br><span class="hljs-string">      </span>|<span class="hljs-string">   +-----------------+   </span>|<br>      |<span class="hljs-string">   </span>|<span class="hljs-string"> return address  </span>|<span class="hljs-string">   </span>|<br>      +------ previous fp   |<span class="hljs-string">   </span>|<br>          |<span class="hljs-string"> saved registers </span>|<span class="hljs-string">   </span>|<br>          |<span class="hljs-string"> local variables </span>|<span class="hljs-string">   </span>|<br>      +-&gt; |<span class="hljs-string">       ...       </span>|<span class="hljs-string">   </span>|<br>      |<span class="hljs-string">   +-----------------+   </span>|<br>      |<span class="hljs-string">   </span>|<span class="hljs-string"> return address  </span>|<span class="hljs-string">   </span>|<br>      |<span class="hljs-string">   </span>|<span class="hljs-string">   previous fp ------+</span><br><span class="hljs-string">      </span>|<span class="hljs-string">   </span>|<span class="hljs-string"> saved registers </span>|<br>      |<span class="hljs-string">   </span>|<span class="hljs-string"> local variables </span>|<br>      |<span class="hljs-string">   </span>|<span class="hljs-string">       ...       </span>|<span class="hljs-string"> &lt;-+</span><br><span class="hljs-string">      </span>|<span class="hljs-string">   +-----------------+   </span>|<br>      |<span class="hljs-string">   </span>|<span class="hljs-string"> return address  </span>|<span class="hljs-string">   </span>|<br>      +------ previous fp   |<span class="hljs-string">   </span>|<br>          |<span class="hljs-string"> saved registers </span>|<span class="hljs-string">   </span>|<br>          |<span class="hljs-string"> local variables </span>|<span class="hljs-string">   </span>|<br>  $fp --&gt; |<span class="hljs-string">       ...       </span>|<span class="hljs-string">   </span>|<br>          +-----------------+   |<span class="hljs-string"></span><br><span class="hljs-string">          </span>|<span class="hljs-string"> return address  </span>|<span class="hljs-string">   </span>|<br>          |<span class="hljs-string">   previous fp ------+</span><br><span class="hljs-string">          </span>|<span class="hljs-string"> saved registers </span>|<br>  $sp --&gt; |<span class="hljs-string"> local variables </span>|<br>          +-----------------+<br><br></code></pre></td></tr></table></figure><ol start="3"><li><code>backtrace</code>函数</li></ol><p>不断通过fp = fp-16获取栈帧地址，对于每个栈帧，打印上级函数的返回地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">backtrace</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  uint64 cur_fp = r_fp();<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;backtrace:\n&quot;</span>);<br>  <span class="hljs-keyword">for</span> (uint64 fp = cur_fp; fp &lt; PGROUNDUP(cur_fp); fp = *((uint64 *)(fp - <span class="hljs-number">16</span>)) ) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p\n&quot;</span>, *((uint64 *)(fp - <span class="hljs-number">8</span>)));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Alarm-hard"><a href="#Alarm-hard" class="headerlink" title="Alarm (hard)"></a>Alarm (hard)</h4><h5 id="任务-1"><a href="#任务-1" class="headerlink" title="任务"></a>任务</h5><p>该节你将为xv6添加对于进程使用CPU时间时能够周期性地发出警报的功能，这对于计算密集型进程限制使用CPU时间或者进程希望周期性地执行某个动作很有用；更进一步，你将实现一个初级形式的用户态中断/故障处理程序，和处理应用中的页错误类似</p><p>首先添加<code>sigalarm(interval, handler)</code>系统调用，如果程序调用<code>sigalarm(n, fn)</code>，则程序每消耗n个ticks，内核调用程序的<code>fn</code>函数，当<code>fn</code>返回，程序应该在之前中断的地方恢复执行；一个tick是xv6的一个计时单元，由硬件时钟生成中断；如果一个应用调用<code>sigalarm(0, 0)</code>，内核应停止周期性地执行alarm调用</p><h5 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h5><ol><li>添加<code>sys_sigalarm</code>、<code>sys_sigreturn</code>两个系统调用定义</li></ol><p>按之前lab添加系统调用的方式即可</p><ol start="2"><li>在<code>proc.h/struct proc</code>添加alarm相关的成员变量</li></ol><p>如下所示，<code>alarm_ticks</code>为alarm的周期，<code>alarm_handler_addr</code>为alarm处理函数的地址，该地址为用户进程的虚拟地址，这两个由<code>sys_sigalarm</code>系统调用参数设置；<code>ticks</code>为当前进程消耗的CPU时间，<code>last_ticks</code>为上一次执行alarm处理函数的开始CPU时间，<code>alarm_regs</code>为执行处理函数时保存与需要恢复的寄存器组值，<code>alarm_running</code>用来标记是否该进程正在执行处理函数中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> alarm_ticks;                   <span class="hljs-comment">// lab alarm</span><br>uint64 alarm_handler_addr;         <span class="hljs-comment">// lab alarm</span><br>uint64 ticks;                      <span class="hljs-comment">// lab alarm</span><br>uint64 last_ticks;                 <span class="hljs-comment">// lab alarm</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">alarm_regs</span> <span class="hljs-title">regs</span>;</span>            <span class="hljs-comment">// lab alarm</span><br><span class="hljs-keyword">int</span> alarm_running;                 <span class="hljs-comment">// lab alarm</span><br></code></pre></td></tr></table></figure><ol start="3"><li>初始化<code>proc</code>结构体alarm相关变量</li></ol><p>在<code>proc.c/allocproc</code>函数中对上述定义的相关变量进行初始化，初始ticks为0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Init ticks for lab alarm</span><br>p-&gt;ticks = <span class="hljs-number">0</span>;<br>p-&gt;last_ticks = <span class="hljs-number">0</span>;<br>p-&gt;alarm_running = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><ol start="4"><li>添加<code>sys_sigalarm</code>系统调用实现</li></ol><p><code>sys_sigalarm</code>对进程<code>proc</code>结构体的<code>alarm_ticks</code>、<code>alarm_handler_addr</code>变量进行设置，同时设置<code>last_ticks</code>为当前<code>ticks</code>，也即从当前开始计时</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">uint64 </span><br><span class="hljs-function"><span class="hljs-title">sys_sigalarm</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> ticks;<br>  uint64 handler_addr;<br><br>  <span class="hljs-keyword">if</span> (argint(<span class="hljs-number">0</span>, &amp;ticks) &lt; <span class="hljs-number">0</span> || argaddr(<span class="hljs-number">1</span>, &amp;handler_addr) &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>  p-&gt;alarm_ticks = ticks;<br>  p-&gt;alarm_handler_addr = handler_addr;<br>  p-&gt;last_ticks = p-&gt;ticks;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li>保存与恢复上下文</li></ol><p>当进程从当前运行地方切换到处理函数入口地址时，应保存切换时的CPU寄存器值，这里在<code>proc.h</code>定义<code>struct alarm_regs</code>结构体，其需要保存的寄存器基本和<code>trapframe</code>一致</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">alarm_regs</span></span><br><span class="hljs-class">&#123;</span><br>  uint64 epc;<br>  uint64 ra;<br>  uint64 sp;<br>  .....<br>  uint64 s10;<br>  uint64 t5;<br>  uint64 t6;<br>&#125;;<br></code></pre></td></tr></table></figure><p>当执行<code>sys_sigalarm</code>系统调用进入内核后，当前进程用户态的上下文，也即执行ecall指令时的状态，保存在进程结构体的<code>trapframe</code>中，由于<code>sys_sigalarm</code>系统调用返回后强制使得该进程跳转到了处理函数去执行，执行完成后在通过<code>sys_sigreturn</code>系统调用恢复，在这个处理函数执行过程中<code>trapframe</code>已经发生了很大变化，因此需要保证<code>sys_sigalarm</code>进入时的<code>trapframe</code>和<code>sys_sigreturn</code>返回时的<code>trapframe</code>一致，即可恢复到执行处理函数之前的位置继续执行</p><p>在<code>trap.c</code>中定义保存与恢复上下文如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">save_regs</span><span class="hljs-params">(struct proc *p)</span></span><br><span class="hljs-function"></span>&#123;<br>  p-&gt;regs.epc = p-&gt;trapframe-&gt;epc;<br>  p-&gt;regs.ra = p-&gt;trapframe-&gt;ra;<br>  p-&gt;regs.sp = p-&gt;trapframe-&gt;sp;<br>  .........<br>  p-&gt;regs.t3 = p-&gt;trapframe-&gt;t3;<br>  p-&gt;regs.t4 = p-&gt;trapframe-&gt;t4;<br>  p-&gt;regs.t5 = p-&gt;trapframe-&gt;t5;<br>  p-&gt;regs.t6 = p-&gt;trapframe-&gt;t6;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">restore_regs</span><span class="hljs-params">(struct proc *p)</span></span><br><span class="hljs-function"></span>&#123;<br>  p-&gt;trapframe-&gt;epc = p-&gt;regs.epc;<br>  p-&gt;trapframe-&gt;ra = p-&gt;regs.ra;<br>  p-&gt;trapframe-&gt;sp = p-&gt;regs.sp;<br>  p-&gt;trapframe-&gt;gp = p-&gt;regs.gp;<br>  .......<br>  p-&gt;trapframe-&gt;t5 = p-&gt;regs.t5;<br>  p-&gt;trapframe-&gt;t6 = p-&gt;regs.t6;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="6"><li>处理时钟中断</li></ol><p>每当进程因为时钟中断陷入后，进程的CPU时间<code>ticks</code>增加，当alarm处理程序未在运行，并且设置了alarm周期时间，则当到期后就开始执行处理函数</p><p>首先<code>p-&gt;last_ticks = p-&gt;ticks</code>设置最后调用处理函数的开始时间为当前<code>ticks</code></p><p><code>save_regs(p)</code>保存了将要调用处理函数之前的CPU寄存器状态</p><p><code>p-&gt;trapframe-&gt;epc = p-&gt;alarm_handler_addr</code>将陷入后的返回地址设置为处理函数的地址，当<code>trampoline.S/userret</code>最后的<code>sret</code>指令执行后，即将PC设置为了处理函数地址，也即执行该处理函数</p><p><code>p-&gt;alarm_running = 1</code>表示该进程的处理函数正在执行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// give up the CPU if this is a timer interrupt.</span><br><span class="hljs-comment">// lab alarm</span><br><span class="hljs-keyword">if</span>(which_dev == <span class="hljs-number">2</span>) &#123;<br>  p-&gt;ticks++;<br>  <span class="hljs-keyword">if</span> (p-&gt;alarm_ticks != <span class="hljs-number">0</span> &amp;&amp; p-&gt;alarm_running == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">if</span> (p-&gt;last_ticks + p-&gt;alarm_ticks &lt;= p-&gt;ticks) &#123;<br>      p-&gt;last_ticks = p-&gt;ticks;<br><br>      save_regs(p);<br>      p-&gt;trapframe-&gt;epc = p-&gt;alarm_handler_addr;<br>      <br>      p-&gt;alarm_running = <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><ol start="7"><li>添加<code>sys_sigreturn</code>系统调用实现</li></ol><p>在<code>sysproc.c</code>中添加<code>sys_sigreturn</code>实现，主要作用是用户的alarm处理函数执行后，恢复到处理函数执行前的状态</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">uint64 </span><br><span class="hljs-function"><span class="hljs-title">sys_sigreturn</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>  restore_regs(p);<br>  p-&gt;alarm_running = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h5><p><img src="https://whileskies-pic.oss-cn-beijing.aliyuncs.com/20210402142321.png" alt="image-20210402142321233"></p><h4 id="实验测试"><a href="#实验测试" class="headerlink" title="实验测试"></a>实验测试</h4><p><img src="https://whileskies-pic.oss-cn-beijing.aliyuncs.com/20210402142613.png" alt="image-20210402142613027"></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p><a href="https://github.com/whileskies/xv6-labs-2020/tree/traps">https://github.com/whileskies/xv6-labs-2020/tree/traps</a></p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>6.S081</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.S081-Lab3: page tables</title>
    <link href="/2021/07/11/6-S081-Lab3-page-tables/"/>
    <url>/2021/07/11/6-S081-Lab3-page-tables/</url>
    
    <content type="html"><![CDATA[<h2 id="Lab3-page-tables"><a href="#Lab3-page-tables" class="headerlink" title="Lab3: page tables"></a>Lab3: page tables</h2><p>Lab3为3个页表相关实验，用于理解os的页表机制</p><h4 id="Print-a-page-table-easy"><a href="#Print-a-page-table-easy" class="headerlink" title="Print a page table (easy)"></a>Print a page table (easy)</h4><h5 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h5><p>按层次输出多级页表的页表项，定义函数<code>vmprint()</code>，参数为level-2级页表地址<code>pagetable_t</code>，并输出pid为1的进程的用户页表</p><p>可以参照<code>freewalk</code>进行递归遍历</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Print page table</span><br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">vmprint_level</span><span class="hljs-params">(<span class="hljs-keyword">pagetable_t</span> pagetable, <span class="hljs-keyword">int</span> level)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> (level &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-keyword">if</span> (level == <span class="hljs-number">2</span>)<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;page table %p\n&quot;</span>, pagetable);<br>  <br>  level = level - <span class="hljs-number">1</span>;<br>  <br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">512</span>; i++) &#123;<br>    <span class="hljs-keyword">pte_t</span> pte = pagetable[i];<br>    <span class="hljs-keyword">if</span> (pte &amp; PTE_V) &#123;<br>      <span class="hljs-keyword">if</span> (level == <span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;..&quot;</span>);<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (level == <span class="hljs-number">0</span>)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;.. ..&quot;</span>);<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (level == <span class="hljs-number">-1</span>)<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;.. .. ..&quot;</span>);<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: pte %p pa %p\n&quot;</span>, i, pte, PTE2PA(pte));<br>      uint64 child = PTE2PA(pte);<br>      vmprint_level((<span class="hljs-keyword">pagetable_t</span>)child, level);<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">vmprint</span><span class="hljs-params">(<span class="hljs-keyword">pagetable_t</span> pagetable)</span></span><br><span class="hljs-function"></span>&#123;<br>  vmprint_level(pagetable, <span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h5><p><img src="https://whileskies-pic.oss-cn-beijing.aliyuncs.com/20210324150317.png" alt="image-20210324150310221"></p><h4 id="A-kernel-page-table-per-process-hard"><a href="#A-kernel-page-table-per-process-hard" class="headerlink" title="A kernel page table per process (hard)"></a>A kernel page table per process (hard)</h4><h5 id="任务-1"><a href="#任务-1" class="headerlink" title="任务"></a>任务</h5><p>实现每个进程一个内核页表</p><p>xv6当位于内核态时使用的是内核页表，xv6有一个内核页表用于对os虚拟地址进行映射，该页表对物理内存进行一一映射，也即内核虚拟地址x映射为物理地址x，如下图所示：</p><img src="https://whileskies-pic.oss-cn-beijing.aliyuncs.com/20210324151158.png" alt="image-20210324151158499" style="zoom:50%;" /><p>同时xv6对于每个进程也有个用户页表，用于映射用户进程的地址空间，用户虚拟地址空间从0开始，如下图所示：</p><img src="https://whileskies-pic.oss-cn-beijing.aliyuncs.com/20210324151523.png" alt="image-20210324151523096" style="zoom:50%;" /><p>然而内核页表不含有进程用户地址空间的映射（如代码段、数据段、堆段、栈段），os在内核态执行时对于这些用户地址是不合法的，因此，当内核在系统调用中需要使用作为参数的用户指针进行返回数据时，内核必须先要将用户指针根据用户页表转换为物理地址。本节以及下一节实验目标是允许内核去直接解引用用户指针所指的地址，而不再先通过用户用户页表转换</p><p>本节任务是修改内核，使得每个进程有一个内核页表的副本，当在内核执行时，使用该内核页表副本，而不是原本的内核页表</p><h5 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h5><ol><li>在进程数据结构中增加内核页表域，位于<code>proc.h</code></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br><br>  <span class="hljs-comment">// p-&gt;lock must be held when using these:</span><br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">procstate</span> <span class="hljs-title">state</span>;</span>        <span class="hljs-comment">// Process state</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">parent</span>;</span>         <span class="hljs-comment">// Parent process</span><br>  <span class="hljs-keyword">void</span> *chan;                  <span class="hljs-comment">// If non-zero, sleeping on chan</span><br>  <span class="hljs-keyword">int</span> killed;                  <span class="hljs-comment">// If non-zero, have been killed</span><br>  <span class="hljs-keyword">int</span> xstate;                  <span class="hljs-comment">// Exit status to be returned to parent&#x27;s wait</span><br>  <span class="hljs-keyword">int</span> pid;                     <span class="hljs-comment">// Process ID</span><br><br>  <span class="hljs-comment">// these are private to the process, so p-&gt;lock need not be held.</span><br>  uint64 kstack;               <span class="hljs-comment">// Virtual address of kernel stack</span><br>  uint64 sz;                   <span class="hljs-comment">// Size of process memory (bytes)</span><br>  <span class="hljs-keyword">pagetable_t</span> pagetable;       <span class="hljs-comment">// User page table</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">trapframe</span> *<span class="hljs-title">trapframe</span>;</span> <span class="hljs-comment">// data page for trampoline.S</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">context</span> <span class="hljs-title">context</span>;</span>      <span class="hljs-comment">// swtch() here to run process</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">ofile</span>[<span class="hljs-title">NOFILE</span>];</span>  <span class="hljs-comment">// Open files</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">cwd</span>;</span>           <span class="hljs-comment">// Current directory</span><br>  <span class="hljs-keyword">char</span> name[<span class="hljs-number">16</span>];               <span class="hljs-comment">// Process name (debugging)</span><br><br>  <span class="hljs-keyword">pagetable_t</span> kernel_pagetable; <span class="hljs-comment">// lab3 user kernel pagetable</span><br>&#125;;<br></code></pre></td></tr></table></figure><ol start="2"><li>参考<code>kvminit</code>定义<code>user_kvminit</code>初始化进程内核页表</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Lab3: A kernel page table per process.</span><br><span class="hljs-function"><span class="hljs-keyword">pagetable_t</span></span><br><span class="hljs-function"><span class="hljs-title">user_kvminit</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">pagetable_t</span> user_kernel_pt = (<span class="hljs-keyword">pagetable_t</span>) kalloc();<br>  <span class="hljs-keyword">if</span> (user_kernel_pt == <span class="hljs-number">0</span>) <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">memset</span>(user_kernel_pt, <span class="hljs-number">0</span>, PGSIZE);<br>  <br><br>  <span class="hljs-comment">// uart registers</span><br>  mappages(user_kernel_pt, UART0, PGSIZE, UART0, PTE_R | PTE_W);<br><br>  <span class="hljs-comment">// virtio mmio disk interface</span><br>  mappages(user_kernel_pt, VIRTIO0, PGSIZE, VIRTIO0, PTE_R | PTE_W);<br><br>  <span class="hljs-comment">// CLINT</span><br>  <span class="hljs-comment">// mappages(user_kernel_pt, CLINT, 0x10000, CLINT, PTE_R | PTE_W);</span><br><br>  <span class="hljs-comment">// PLIC</span><br>  mappages(user_kernel_pt, PLIC, <span class="hljs-number">0x400000</span>, PLIC, PTE_R | PTE_W);<br><br>  <span class="hljs-comment">// map kernel text executable and read-only.</span><br>  mappages(user_kernel_pt, KERNBASE, (uint64)etext-KERNBASE, KERNBASE, PTE_R | PTE_X);<br><br>  <span class="hljs-comment">// map kernel data and the physical RAM we&#x27;ll make use of.</span><br>  mappages(user_kernel_pt, (uint64)etext, PHYSTOP-(uint64)etext, (uint64)etext, PTE_R | PTE_W);<br><br>  <span class="hljs-comment">// map the trampoline for trap entry/exit to</span><br>  <span class="hljs-comment">// the highest virtual address in the kernel.</span><br>  mappages(user_kernel_pt, TRAMPOLINE, PGSIZE, (uint64)trampoline, PTE_R | PTE_X);<br><br>  <span class="hljs-keyword">return</span> user_kernel_pt;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>初始化进程内核页表</li></ol><p>在<code>proc.c/allocproc</code>函数中当分配一个进程时，初始化进程内核页表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// An empty user page table.</span><br>p-&gt;pagetable = proc_pagetable(p);<br><span class="hljs-keyword">if</span>(p-&gt;pagetable == <span class="hljs-number">0</span>)&#123;<br>  freeproc(p);<br>  release(&amp;p-&gt;lock);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// Init kernel page table per process.</span><br>p-&gt;kernel_pagetable = user_kvminit();<br><span class="hljs-keyword">if</span> (p-&gt;kernel_pagetable == <span class="hljs-number">0</span>) &#123;<br>  freeproc(p);<br>  release(&amp;p-&gt;lock);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>每个进程内核页表映射进程的内核栈</li></ol><p>每个进程有两个栈，一个是用户栈，当进程在用户态执行时使用该栈，当该进程陷入后，使用该进程的内核栈，在之前只有一个内核页表时，<code>proc.c/procinit</code>函数中分配进程内核栈物理空间，内核页表对进程内核栈进行映射，如下代码所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Allocate a page for the process&#x27;s kernel stack.</span><br><span class="hljs-comment">// Map it high in memory, followed by an invalid</span><br><span class="hljs-comment">// guard page.</span><br><span class="hljs-keyword">char</span> *pa = kalloc();<br><span class="hljs-keyword">if</span>(pa == <span class="hljs-number">0</span>)<br>  panic(<span class="hljs-string">&quot;kalloc&quot;</span>);<br>uint64 va = KSTACK((<span class="hljs-keyword">int</span>) (p - proc));<br>kvmmap(va, (uint64)pa, PGSIZE, PTE_R | PTE_W);<br>p-&gt;kstack = va;<br></code></pre></td></tr></table></figure><p>当每个进程一个内核页表时，进程陷入后使用的是该进程的内核页表，运行的栈为该进程的内核栈，因此进程内核页表应对进程内核栈进行映射，将<code>proc.c/procinit</code>的上述代码移动到<code>/proc.c/allocproc</code>中去，并且被映射的页表改为进程内核页表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Allocate a page for the process&#x27;s kernel stack.</span><br><span class="hljs-comment">// Map it high in memory, followed by an invalid</span><br><span class="hljs-comment">// guard page.</span><br><span class="hljs-keyword">char</span> *pa = kalloc();<br><span class="hljs-keyword">if</span>(pa == <span class="hljs-number">0</span>)<br>  panic(<span class="hljs-string">&quot;kalloc&quot;</span>);<br>uint64 va = KSTACK((<span class="hljs-keyword">int</span>) (p - proc));<br>mappages(p-&gt;kernel_pagetable, va, PGSIZE, (uint64)pa, PTE_R | PTE_W);<br>p-&gt;kstack = va;<br></code></pre></td></tr></table></figure><ol start="5"><li>修改<code>proc.c/scheduler</code></li></ol><p>使得切换进程时应用该内核页表，当进程通过<code>switch</code>切换回去时，该过程为陷入的返回过程，在<code>trap.c/usertrapret</code>中，有保存当前寄存器页表的操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// set up trapframe values that uservec will need when</span><br><span class="hljs-comment">// the process next re-enters the kernel.</span><br>p-&gt;trapframe-&gt;kernel_satp = r_satp();         <span class="hljs-comment">// kernel page table</span><br>p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; <span class="hljs-comment">// process&#x27;s kernel stack</span><br>p-&gt;trapframe-&gt;kernel_trap = (uint64)usertrap;<br>p-&gt;trapframe-&gt;kernel_hartid = r_tp();         <span class="hljs-comment">// hartid for cpuid(</span><br></code></pre></td></tr></table></figure><p>若在<code>switch</code>之前将寄存器页表从内核页表切换为进程内核页表，则当进程返回用户态并再次陷入后就会使用进程内核页表了，代码修改如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">p-&gt;state = RUNNING;<br>c-&gt;proc = p;<br><br>w_satp(MAKE_SATP(p-&gt;kernel_pagetable));<br>sfence_vma();<br><br>swtch(&amp;c-&gt;context, &amp;p-&gt;context);<br></code></pre></td></tr></table></figure><p>如果没有进程需要调度时，仍然使用内核页表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(found == <span class="hljs-number">0</span>) &#123;<br>  w_satp(MAKE_SATP(kernel_pagetable));<br>  sfence_vma();<br><br>  intr_on();<br>  <span class="hljs-function"><span class="hljs-keyword">asm</span> <span class="hljs-title">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;wfi&quot;</span>)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="6"><li>释放进程</li></ol><p>当需要释放进程时，同时也应释放该进程的内核栈，进程内核页表，但不应该释放进程内核页表所映射的物理地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (p-&gt;kstack) &#123;<br>  <span class="hljs-keyword">pte_t</span> *pte = walk(p-&gt;kernel_pagetable, p-&gt;kstack, <span class="hljs-number">0</span>);<br>  uint64 pa = (uint64)PTE2PA(*pte);<br>  kfree((<span class="hljs-keyword">void</span> *)pa);  <br>&#125;<br><br><span class="hljs-keyword">if</span> (p-&gt;kernel_pagetable)<br>  free_pro_kernel_pagetable(p-&gt;kernel_pagetable);<br>p-&gt;kernel_pagetable = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><ol start="7"><li>释放进程内核页表</li></ol><p>递归释放进程内核页表，当不释放页表所映射的物理页</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Free process kernel pagetable for lab3</span><br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">free_pro_kernel_pagetable</span><span class="hljs-params">(<span class="hljs-keyword">pagetable_t</span> pagetable)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">512</span>; i++) &#123;<br>    <span class="hljs-keyword">pte_t</span> pte = pagetable[i];<br><span class="hljs-keyword">if</span> ((pte &amp; PTE_V) &amp;&amp; (pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="hljs-number">0</span>) &#123;<br>      uint64 child = PTE2PA(pte);<br>      free_pro_kernel_pagetable((<span class="hljs-keyword">pagetable_t</span>)child);<br>      pagetable[i] = <span class="hljs-number">0</span>;<br>&#125;<br>  &#125;<br>  kfree((<span class="hljs-keyword">void</span>*)pagetable);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="8"><li>修改bug</li></ol><p>将<code>vm.c/kvmpa</code>中的<code>pte = walk(kernel_pagetable, va, 0);</code>修改为如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// pte = walk(kernel_pagetable, va, 0);</span><br><span class="hljs-comment">// process kernel pagetable has the map on the process kernel stack</span><br>pte = walk(myproc()-&gt;kernel_pagetable, va, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span>(pte == <span class="hljs-number">0</span>)<br>  panic(<span class="hljs-string">&quot;kvmpa&quot;</span>)<br></code></pre></td></tr></table></figure><ol start="9"><li>其他问题</li></ol><p>在使用<code>usertests</code>程序进行测试时，会遇到有时能全通过，有时出现panic，可以在<code>switch</code>之后再切换回内核页表，如下图，调度器使用的是内核栈，其他进程陷入时使用的是进程内核栈，内核页表和进程内核页表映射不完全一致</p><img src="https://whileskies-pic.oss-cn-beijing.aliyuncs.com/20210324162457.png" alt="image-20210324162457924" style="zoom:67%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">w_satp(MAKE_SATP(p-&gt;kernel_pagetable));<br>sfence_vma();<br><br>swtch(&amp;c-&gt;context, &amp;p-&gt;context);<br><br>kvminithart();<br><br>c-&gt;proc = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><h5 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h5><p><img src="https://whileskies-pic.oss-cn-beijing.aliyuncs.com/20210324162943.png" alt="image-20210324162943188"></p><h4 id="Simplify-copyin-copyinstr-hard"><a href="#Simplify-copyin-copyinstr-hard" class="headerlink" title="Simplify copyin/copyinstr (hard)"></a>Simplify copyin/copyinstr (hard)</h4><h5 id="任务-2"><a href="#任务-2" class="headerlink" title="任务"></a>任务</h5><p>内核的<code>copyin</code>函数读取用户地址指针指向的内存，因此需用通过进程的用户页表转换为物理地址来访问。实验该部分的任务是给每个进程的内核页表添加该进程虚拟地址的映射，以允许<code>copyin</code>可以直接解引用用户指针</p><h5 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h5><p>主要思路是在对进程用户页表进行映射的同时，将用户虚拟地址映射到用户内核页表</p><ol><li>替换<code>copyin</code>与<code>copyinstr</code>实现</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Copy from user to kernel.</span><br><span class="hljs-comment">// Copy len bytes to dst from virtual address srcva in a given page table.</span><br><span class="hljs-comment">// Return 0 on success, -1 on error.</span><br><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">copyin</span><span class="hljs-params">(<span class="hljs-keyword">pagetable_t</span> pagetable, <span class="hljs-keyword">char</span> *dst, uint64 srcva, uint64 len)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> copyin_new(pagetable, dst, srcva, len);<br>&#125;<br><br><span class="hljs-comment">// Copy a null-terminated string from user to kernel.</span><br><span class="hljs-comment">// Copy bytes to dst from virtual address srcva in a given page table,</span><br><span class="hljs-comment">// until a &#x27;\0&#x27;, or max.</span><br><span class="hljs-comment">// Return 0 on success, -1 on error.</span><br><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">copyinstr</span><span class="hljs-params">(<span class="hljs-keyword">pagetable_t</span> pagetable, <span class="hljs-keyword">char</span> *dst, uint64 srcva, uint64 max)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> copyinstr_new(pagetable, dst, srcva, max);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>修改<code>vm.c/uvmcopy</code>，对用户页表映射时，同时映射用户内核页表</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">uvmcopy</span><span class="hljs-params">(<span class="hljs-keyword">pagetable_t</span> old, <span class="hljs-keyword">pagetable_t</span> <span class="hljs-keyword">new</span>, <span class="hljs-keyword">pagetable_t</span> kernelpt, uint64 sz)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">pte_t</span> *pte;<br>  uint64 pa, i;<br>  uint flags;<br>  <span class="hljs-keyword">char</span> *mem;<br><br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; sz; i += PGSIZE)&#123;<br>    <span class="hljs-keyword">if</span>((pte = walk(old, i, <span class="hljs-number">0</span>)) == <span class="hljs-number">0</span>)<br>      panic(<span class="hljs-string">&quot;uvmcopy: pte should exist&quot;</span>);<br>    <span class="hljs-keyword">if</span>((*pte &amp; PTE_V) == <span class="hljs-number">0</span>)<br>      panic(<span class="hljs-string">&quot;uvmcopy: page not present&quot;</span>);<br>    pa = PTE2PA(*pte);<br>    flags = PTE_FLAGS(*pte);<br>    <span class="hljs-keyword">if</span>((mem = kalloc()) == <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">goto</span> err;<br>    memmove(mem, (<span class="hljs-keyword">char</span>*)pa, PGSIZE);<br>    <span class="hljs-keyword">if</span>(mappages(<span class="hljs-keyword">new</span>, i, PGSIZE, (uint64)mem, flags) != <span class="hljs-number">0</span> ||<br>      mappages(kernelpt, i, PGSIZE, (uint64)mem, flags &amp; ~PTE_U) != <span class="hljs-number">0</span>)&#123;<br>      kfree(mem);<br>      <span class="hljs-keyword">goto</span> err;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br> err:<br>  uvmunmap(<span class="hljs-keyword">new</span>, <span class="hljs-number">0</span>, i / PGSIZE, <span class="hljs-number">1</span>);<br>  uvmunmap(kernelpt, <span class="hljs-number">0</span>, i / PGSIZE, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>修改<code>vm.c/uvmalloc</code>，对用户页表映射时，同时映射用户内核页表</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">uint64</span><br><span class="hljs-function"><span class="hljs-title">uvmalloc</span><span class="hljs-params">(<span class="hljs-keyword">pagetable_t</span> pagetable, <span class="hljs-keyword">pagetable_t</span> kernelpt, uint64 oldsz, uint64 newsz)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">char</span> *mem;<br>  uint64 a;<br><br>  <span class="hljs-keyword">if</span>(newsz &lt; oldsz)<br>    <span class="hljs-keyword">return</span> oldsz;<br><br>  oldsz = PGROUNDUP(oldsz);<br>  <span class="hljs-keyword">for</span>(a = oldsz; a &lt; newsz; a += PGSIZE)&#123;<br>    mem = kalloc();<br>    <span class="hljs-keyword">if</span>(mem == <span class="hljs-number">0</span>)&#123;<br>      uvmdealloc(pagetable, a, oldsz);<br>      uvmdealloc_nofree(kernelpt, a, oldsz);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-built_in">memset</span>(mem, <span class="hljs-number">0</span>, PGSIZE);<br>    <span class="hljs-keyword">if</span>(mappages(pagetable, a, PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) != <span class="hljs-number">0</span> ||<br>       mappages(kernelpt, a, PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R)) &#123;<br>      kfree(mem);<br>      uvmdealloc(pagetable, a, oldsz);<br>      uvmdealloc_nofree(kernelpt, a, oldsz);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> newsz;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>修改<code>vm.c/uvminit</code></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">uvminit</span><span class="hljs-params">(<span class="hljs-keyword">pagetable_t</span> pagetable, <span class="hljs-keyword">pagetable_t</span> kernelpt, uchar *src, uint sz)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">char</span> *mem;<br><br>  <span class="hljs-keyword">if</span>(sz &gt;= PGSIZE)<br>    panic(<span class="hljs-string">&quot;inituvm: more than a page&quot;</span>);<br>  mem = kalloc();<br>  <span class="hljs-built_in">memset</span>(mem, <span class="hljs-number">0</span>, PGSIZE);<br>  mappages(pagetable, <span class="hljs-number">0</span>, PGSIZE, (uint64)mem, PTE_W|PTE_R|PTE_X|PTE_U);<br>  mappages(kernelpt, <span class="hljs-number">0</span>, PGSIZE, (uint64)mem, PTE_W|PTE_R|PTE_X);<br>  memmove(mem, src, sz);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li>修改<code>proc.c/fork</code></li></ol><p>fork复制父进程的地址空间到子进程，复制用户页表同时，将其映射到子进程内核页表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(uvmcopy(p-&gt;pagetable, np-&gt;pagetable, np-&gt;kernel_pagetable, p-&gt;sz) &lt; <span class="hljs-number">0</span>)&#123;<br>    freeproc(np);<br>    release(&amp;np-&gt;lock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="6"><li>修改<code>proc.c/exec</code></li></ol><p>创建进程时需要对用户虚拟地址进行映射，应同时映射到进程内核页表</p><p>因为此时正使用用户内核页表，释放旧的用户内核页表之前，应重新设置页表寄存器为新的用户内核页表，同时刷新TLB</p><p><img src="https://whileskies-pic.oss-cn-beijing.aliyuncs.com/20210330094716.png" alt="image-20210330094709357"></p><p><img src="https://whileskies-pic.oss-cn-beijing.aliyuncs.com/20210330094738.png" alt="image-20210330094737962"></p><ol start="7"><li>修改<code>sysproc.c/sys_sbrk</code></li></ol><p>防止在用户内核页表中的用户虚拟地址超过PLIC限制</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">uint64</span><br><span class="hljs-function"><span class="hljs-title">sys_sbrk</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> addr;<br>  <span class="hljs-keyword">int</span> n;<br><br>  <span class="hljs-keyword">if</span>(argint(<span class="hljs-number">0</span>, &amp;n) &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  addr = myproc()-&gt;sz;<br>  <span class="hljs-keyword">if</span> (PGROUNDUP(addr + n) &gt;= PLIC) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span>(growproc(n) &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  <span class="hljs-keyword">return</span> addr;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="8"><li>复制并修改<code>vm.c/walkaddr</code>函数为<code>vm.c/kernelpt_walkaddr</code></li></ol><p>由于<code>walkaddr</code>函数只能转换用户页表的虚拟地址，因此复制一份可以转换内核页表的虚拟地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Look up a virtual address, return the physical address,</span><br><span class="hljs-comment">// or 0 if not mapped.</span><br><span class="hljs-comment">// Can be used to look up kernel page.</span><br><span class="hljs-function">uint64</span><br><span class="hljs-function"><span class="hljs-title">kernelpt_walkaddr</span><span class="hljs-params">(<span class="hljs-keyword">pagetable_t</span> pagetable, uint64 va)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">pte_t</span> *pte;<br>  uint64 pa;<br><br>  <span class="hljs-keyword">if</span>(va &gt;= MAXVA)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>  pte = walk(pagetable, va, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span>(pte == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span>((*pte &amp; PTE_V) == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  pa = PTE2PA(*pte);<br>  <span class="hljs-keyword">return</span> pa;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="9"><li>复制并修改<code>vm.c/uvmdealloc函数为</code>vm.c/uvmdealloc_nofree`</li></ol><p>由于<code>uvmdealloc</code>函数用于取消用户页表的映射，并删除物理页，但是用户内核页表取消映射时不能删除物理页，因此修改此函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">uint64</span><br><span class="hljs-function"><span class="hljs-title">uvmdealloc_nofree</span><span class="hljs-params">(<span class="hljs-keyword">pagetable_t</span> pagetable, uint64 oldsz, uint64 newsz)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span>(newsz &gt;= oldsz)<br>    <span class="hljs-keyword">return</span> oldsz;<br><br>  <span class="hljs-keyword">if</span>(PGROUNDUP(newsz) &lt; PGROUNDUP(oldsz))&#123;<br>    <span class="hljs-keyword">int</span> npages = (PGROUNDUP(oldsz) - PGROUNDUP(newsz)) / PGSIZE;<br>    uvmunmap(pagetable, PGROUNDUP(newsz), npages, <span class="hljs-number">0</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> newsz;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="实验测试"><a href="#实验测试" class="headerlink" title="实验测试"></a>实验测试</h4><p><img src="https://whileskies-pic.oss-cn-beijing.aliyuncs.com/20210330100558.png" alt="image-20210330100558882"></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p><a href="https://github.com/whileskies/xv6-labs-2020/tree/pgtbl">https://github.com/whileskies/xv6-labs-2020/tree/pgtbl</a></p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>6.S081</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.S081-Lab2: system calls</title>
    <link href="/2021/07/11/6-S081-Lab2-system-calls/"/>
    <url>/2021/07/11/6-S081-Lab2-system-calls/</url>
    
    <content type="html"><![CDATA[<h2 id="Lab2-system-calls"><a href="#Lab2-system-calls" class="headerlink" title="Lab2: system calls"></a>Lab2: system calls</h2><p>Lab2为xv6添加一些系统调用，以便了解系统调用过程</p><h4 id="System-call-tracing-moderate"><a href="#System-call-tracing-moderate" class="headerlink" title="System call tracing (moderate)"></a>System call tracing (moderate)</h4><h5 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h5><p>添加一个<code>trace</code>系统调用，参数为系统调用号掩码，用于追踪系统调用的路径以及返回值</p><h5 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h5><ol><li>首先为<code>proc.h</code>中的<code>proc</code>结构体添加一个跟踪掩码字段：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// these are private to the process, so p-&gt;lock need not be held.</span><br>  uint64 kstack;               <span class="hljs-comment">// Virtual address of kernel stack</span><br>  uint64 sz;                   <span class="hljs-comment">// Size of process memory (bytes)</span><br>  <span class="hljs-keyword">pagetable_t</span> pagetable;       <span class="hljs-comment">// User page table</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">trapframe</span> *<span class="hljs-title">trapframe</span>;</span> <span class="hljs-comment">// data page for trampoline.S</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">context</span> <span class="hljs-title">context</span>;</span>      <span class="hljs-comment">// swtch() here to run process</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">ofile</span>[<span class="hljs-title">NOFILE</span>];</span>  <span class="hljs-comment">// Open files</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">cwd</span>;</span>           <span class="hljs-comment">// Current directory</span><br>  <span class="hljs-keyword">char</span> name[<span class="hljs-number">16</span>];               <span class="hljs-comment">// Process name (debugging)</span><br>  <span class="hljs-keyword">int</span> trace_mask;              <span class="hljs-comment">// trace syscall mas</span><br></code></pre></td></tr></table></figure><ol start="2"><li>为给系统调用添加系统调用号，如<code>syscall.h</code>、<code>syscall.c</code>文件中：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SYS_trace  22</span><br><br>[SYS_mkdir]   sys_mkdir,<br>[SYS_close]   sys_close,<br>[SYS_trace]   sys_trace,<br></code></pre></td></tr></table></figure><ol start="3"><li>在内核系统调用出口拦截系统调用名称以及返回值，需要一个字符串数组将系统调用号转为系统调用名称：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> *syscall_name[] = &#123;<br>        <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;fork&quot;</span>, <span class="hljs-string">&quot;exit&quot;</span>, <span class="hljs-string">&quot;wait&quot;</span>, <span class="hljs-string">&quot;pipe&quot;</span>, <span class="hljs-string">&quot;read&quot;</span>, <span class="hljs-string">&quot;kill&quot;</span>, <span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-string">&quot;fstat&quot;</span>, <span class="hljs-string">&quot;chdir&quot;</span>, <span class="hljs-string">&quot;dup&quot;</span>,<br>        <span class="hljs-string">&quot;getpid&quot;</span>, <span class="hljs-string">&quot;sbrk&quot;</span>, <span class="hljs-string">&quot;sleep&quot;</span>, <span class="hljs-string">&quot;uptime&quot;</span>, <span class="hljs-string">&quot;open&quot;</span>, <span class="hljs-string">&quot;write&quot;</span>, <span class="hljs-string">&quot;mknod&quot;</span>, <span class="hljs-string">&quot;unlink&quot;</span>, <span class="hljs-string">&quot;link&quot;</span>, <span class="hljs-string">&quot;mkdir&quot;</span>,<br>        <span class="hljs-string">&quot;close&quot;</span>, <span class="hljs-string">&quot;trace&quot;</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">syscall</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> num;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>  num = p-&gt;trapframe-&gt;a7;<br>  <span class="hljs-keyword">if</span>(num &gt; <span class="hljs-number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;<br>    p-&gt;trapframe-&gt;a0 = syscalls[num]();<br><br>    <span class="hljs-keyword">if</span> (p-&gt;trace_mask &amp; (<span class="hljs-number">1</span> &lt;&lt; num)) &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>, p-&gt;pid, syscall_name[num], p-&gt;trapframe-&gt;a0);<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %s: unknown sys call %d\n&quot;</span>,<br>            p-&gt;pid, p-&gt;name, num);<br>    p-&gt;trapframe-&gt;a0 = <span class="hljs-number">-1</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>在<code>sysproc.c/sys_trace</code>设置进程的掩码：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">uint64</span><br><span class="hljs-function"><span class="hljs-title">sys_trace</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> mask;<br><br>  <span class="hljs-keyword">if</span> (argint(<span class="hljs-number">0</span>, &amp;mask) &lt; <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">pro</span> =</span> myproc();<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;trace pid: %d\n&quot;</span>, pro-&gt;pid);<br>  pro-&gt;trace_mask = mask;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><ol start="5"><li>进程清除时也应清除相应掩码 <code>proc.c/freeproc</code>：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">p-&gt;chan = <span class="hljs-number">0</span>;<br>p-&gt;killed = <span class="hljs-number">0</span>;<br>p-&gt;xstate = <span class="hljs-number">0</span>;<br>p-&gt;state = UNUSED;<br><br><span class="hljs-comment">// trace</span><br>p-&gt;trace_mask = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><ol start="6"><li>fork时子进程也复制到该掩码 <code>proc.c/fork</code>：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">pid = np-&gt;pid;<br><br>np-&gt;state = RUNNABLE;<br><br><span class="hljs-comment">// trace</span><br>np-&gt;trace_mask = p-&gt;trace_mask;<br><br>release(&amp;np-&gt;lock)<br></code></pre></td></tr></table></figure><h5 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h5><p><img src="https://whileskies-pic.oss-cn-beijing.aliyuncs.com/20210322140342.png" alt="image-20210322140342934"></p><h4 id="Sysinfo-moderate"><a href="#Sysinfo-moderate" class="headerlink" title="Sysinfo (moderate)"></a>Sysinfo (moderate)</h4><h5 id="任务-1"><a href="#任务-1" class="headerlink" title="任务"></a>任务</h5><p>实现sysinfo系统调用用于获取当前的空闲内存字节数以及状态为<code>UNUSED</code>的进程数</p><h5 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h5><ol><li>获取空闲内存字节数</li></ol><p>内存以页为单位进行分配和释放，每个空闲内存将其作为<code>struct run</code>结构体，最低的以<code>struct run</code>结构体指针大小的字节为next域，指向下一空闲内存页的地址</p><p>实现时遍历空闲页列表即可，当run指针为NULL时停止</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Get the number of bytes of free memory</span><br><span class="hljs-function">uint64</span><br><span class="hljs-function"><span class="hljs-title">get_free_memory</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">r</span>;</span><br>  uint64 pages = <span class="hljs-number">0</span>;<br><br>  acquire(&amp;kmem.lock);<br>  r = kmem.freelist;<br>  <span class="hljs-keyword">while</span> (r) &#123;<br>    pages++;<br>    r = r-&gt;next;   <br>  &#125;<br>  release(&amp;kmem.lock);<br><br>  <span class="hljs-keyword">return</span> pages * PGSIZE;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>获取UNUSED进程数目</li></ol><p>遍历所有的proc结构，统计<code>UNUSED</code>状态的数目</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Get the num of proccesses</span><br><span class="hljs-function">uint64</span><br><span class="hljs-function"><span class="hljs-title">get_proccesses_num</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span>;</span><br>  uint64 num = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;<br>    <span class="hljs-keyword">if</span>(p-&gt;state != UNUSED) <br>      num++;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> num;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>实现sysinfo系统调用</li></ol><p>参考<code>sys_fstat</code>等函数参数的传递以及指针类型数据复制的方式，将内核的数据复制到参数指针所指向的该进程用户态内存区域：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">uint64</span><br><span class="hljs-function"><span class="hljs-title">sys_sysinfo</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  uint64 param;<br>  <span class="hljs-keyword">if</span>(argaddr(<span class="hljs-number">0</span>, &amp;param) &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sysinfo</span> <span class="hljs-title">info</span>;</span><br>  info.freemem = get_free_memory();<br>  info.nproc = get_proccesses_num();<br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>  <span class="hljs-keyword">if</span> (copyout(p-&gt;pagetable, param, (<span class="hljs-keyword">char</span> *)&amp;info, <span class="hljs-keyword">sizeof</span>(info)) &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="实验测试"><a href="#实验测试" class="headerlink" title="实验测试"></a>实验测试</h4><p>当在win10上使用<code>git clone</code>并完成实验后，使用ubuntu虚拟机运行测试，读取README文件时和要求的不一致，若在ubuntu上<code>git clone</code>，则可以通过测试，推测是不同os换行的符号不同，git进行了转换，下图为在ubuntu上<code>git clone</code>并复制README文件到项目后的运行结果</p><p>此外每个测试python脚本第一行<code>#!/usr/bin/env python</code>换行符在win下也应切换为LF格式（原本为CRLF）才可在ubuntu虚拟机上正常测试</p><p><img src="https://whileskies-pic.oss-cn-beijing.aliyuncs.com/20210322142413.png" alt="image-20210322142413089"></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p><a href="https://github.com/whileskies/xv6-labs-2020/tree/syscall">https://github.com/whileskies/xv6-labs-2020/tree/syscall</a></p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>6.S081</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.S081-Lab1: Xv6 and Unix utilities</title>
    <link href="/2021/07/11/6-S081-Lab1-Xv6-and-Unix-utilities/"/>
    <url>/2021/07/11/6-S081-Lab1-Xv6-and-Unix-utilities/</url>
    
    <content type="html"><![CDATA[<h2 id="Lab1-Xv6-and-Unix-utilities"><a href="#Lab1-Xv6-and-Unix-utilities" class="headerlink" title="Lab1: Xv6 and Unix utilities"></a>Lab1: Xv6 and Unix utilities</h2><p>Lab1主要是了解并运行RiscV版本的XV6，并为其添加一些用户态程序</p><h4 id="Boot-xv6-easy"><a href="#Boot-xv6-easy" class="headerlink" title="Boot xv6 (easy)"></a>Boot xv6 (easy)</h4><p>使用<code>make qemu</code>运行xv6，并运行<code>ls</code>等程序</p><h4 id="sleep-easy"><a href="#sleep-easy" class="headerlink" title="sleep (easy)"></a>sleep (easy)</h4><h5 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h5><p>调用内核sleep系统调用完成功能</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;user.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> time;<br><br>  <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Usage: sleep time\n\n&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br><br>  time = atoi(argv[<span class="hljs-number">1</span>]);<br>  sleep(time);<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在Makefile的<code>UPROGS</code>中添加<code>$U/_sleep\</code> </p><h4 id="pingpong-easy"><a href="#pingpong-easy" class="headerlink" title="pingpong (easy)"></a>pingpong (easy)</h4><h5 id="任务-1"><a href="#任务-1" class="headerlink" title="任务"></a>任务</h5><p>创建一对父子进程，该对进程使用管道通信</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> p2c[<span class="hljs-number">2</span>], c2p[<span class="hljs-number">2</span>];<br>  <span class="hljs-keyword">int</span> child_id;<br>  <span class="hljs-keyword">char</span> *ping = <span class="hljs-string">&quot;ping&quot;</span>;<br>  <span class="hljs-keyword">char</span> *pong = <span class="hljs-string">&quot;pong&quot;</span>;<br>  <span class="hljs-keyword">char</span> buf[<span class="hljs-number">512</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><br>  pipe(p2c);<br>  pipe(c2p);<br><br>  child_id = fork();<br>  <span class="hljs-keyword">if</span> (child_id != <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">//parent</span><br>    close(p2c[<span class="hljs-number">0</span>]);<br>    close(c2p[<span class="hljs-number">1</span>]);<br><br>    write(p2c[<span class="hljs-number">1</span>], ping, <span class="hljs-built_in">strlen</span>(ping));<br><br>    <span class="hljs-comment">//wait((int *)0);</span><br>    read(c2p[<span class="hljs-number">0</span>], buf, <span class="hljs-keyword">sizeof</span>(buf));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: received %s\n&quot;</span>, getpid(), buf);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">//child</span><br>    close(p2c[<span class="hljs-number">1</span>]);<br>    close(c2p[<span class="hljs-number">0</span>]);<br><br>    read(p2c[<span class="hljs-number">0</span>], buf, <span class="hljs-keyword">sizeof</span>(buf));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: received %s\n&quot;</span>, getpid(), buf);<br><br>    write(c2p[<span class="hljs-number">1</span>], pong, <span class="hljs-built_in">strlen</span>(pong));<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="primes-moderate-hard"><a href="#primes-moderate-hard" class="headerlink" title="primes (moderate)/(hard)"></a>primes (moderate)/(hard)</h4><h5 id="任务-2"><a href="#任务-2" class="headerlink" title="任务"></a>任务</h5><p>使用<code>pipe</code>、<code>fork</code>组成一管道过滤器，第一个进程输出2，并过滤2-35中2的倍数的数，第二个进程输出3并过滤3的倍数的数…</p><img src="https://whileskies-pic.oss-cn-beijing.aliyuncs.com/20210321224328.png" alt="image-20210321224322050" style="zoom: 80%;" /><h5 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h5><p>首先main函数初始管道，将2-35写入管道，并关闭写管道，调用filter函数处理，filter函数用于递归处理该问题，参数为上一层管道数组，从管道读端读入上一层的数字，并创建一个新管道，对数字过滤后传入下一层，下一层即为通过fork创建的子进程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">filter</span><span class="hljs-params">(<span class="hljs-keyword">int</span> lpipe[])</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> rpipe[<span class="hljs-number">2</span>];<br>  pipe(rpipe);<br><br>  <span class="hljs-keyword">int</span> primes[<span class="hljs-number">50</span>];<br>  <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">char</span> buf[<span class="hljs-number">1</span>];<br><br>  <span class="hljs-keyword">while</span> ((read(lpipe[<span class="hljs-number">0</span>], buf, <span class="hljs-keyword">sizeof</span>(buf))) != <span class="hljs-number">0</span>) &#123;<br>    primes[cnt++] = buf[<span class="hljs-number">0</span>];<br>  &#125;<br>  close(lpipe[<span class="hljs-number">0</span>]);<br><br>  <span class="hljs-keyword">if</span> (cnt == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-keyword">int</span> first = primes[<span class="hljs-number">0</span>];<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;prime %d\n&quot;</span>, first);<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; cnt; i++) &#123;<br>    <span class="hljs-keyword">if</span> (primes[i] % first != <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">char</span> p = primes[i];<br>      write(rpipe[<span class="hljs-number">1</span>], &amp;p, <span class="hljs-number">1</span>);<br>    &#125;<br>  &#125;<br>  close(rpipe[<span class="hljs-number">1</span>]);<br><br>  <span class="hljs-keyword">int</span> pid = fork();<br>  <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">//child</span><br>    filter(rpipe);<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> lpipe[<span class="hljs-number">2</span>];<br><br>  pipe(lpipe);<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-number">35</span>; i++) &#123;<br>    <span class="hljs-keyword">char</span> p = i;<br>    write(lpipe[<span class="hljs-number">1</span>], &amp;p, <span class="hljs-number">1</span>);<br>  &#125;<br>  close(lpipe[<span class="hljs-number">1</span>]);<br><br>  filter(lpipe);<br><br>  wait((<span class="hljs-keyword">int</span> *) <span class="hljs-number">0</span>);<br><br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h5><p><img src="https://whileskies-pic.oss-cn-beijing.aliyuncs.com/20210321225353.png" alt="image-20210321225351704"></p><h4 id="find-moderate"><a href="#find-moderate" class="headerlink" title="find (moderate)"></a>find (moderate)</h4><h5 id="任务-3"><a href="#任务-3" class="headerlink" title="任务"></a>任务</h5><p>在一个目录树中搜索特定名称的所有文件</p><h5 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h5><p>递归搜索目录中的指定文件即可，增加了<code>.</code>、<code>*</code>的通配符功能，正则匹配代码参考自<a href="https://leetcode-cn.com/problems/wildcard-matching/">LeetCode 44题</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;user/user.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;kernel/fs.h&quot;</span></span><br><br><span class="hljs-comment">// int</span><br><span class="hljs-comment">// match(char *filename, char *name) &#123;</span><br><span class="hljs-comment">//   return strcmp(filename, name) == 0;</span><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-comment">// &#x27;.&#x27; Matches any single character.​​​​</span><br><span class="hljs-comment">// &#x27;*&#x27; Matches zero or more of the preceding element.</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">match</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* s, <span class="hljs-keyword">char</span>* p)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (!*p) <span class="hljs-keyword">return</span> !*s;<br>  <span class="hljs-keyword">if</span> (*(p + <span class="hljs-number">1</span>) != <span class="hljs-string">&#x27;*&#x27;</span>) <br>    <span class="hljs-keyword">return</span> *s == *p || (*p == <span class="hljs-string">&#x27;.&#x27;</span> &amp;&amp; *s != <span class="hljs-string">&#x27;\0&#x27;</span>) ? match(s + <span class="hljs-number">1</span>, p + <span class="hljs-number">1</span>) : <span class="hljs-number">0</span>; <br>  <span class="hljs-keyword">else</span> <br>    <span class="hljs-keyword">return</span> *s == *p || (*p == <span class="hljs-string">&#x27;.&#x27;</span> &amp;&amp; *s != <span class="hljs-string">&#x27;\0&#x27;</span>) ? match(s, p + <span class="hljs-number">2</span>) || match(s + <span class="hljs-number">1</span>, p) : match(s, p + <span class="hljs-number">2</span>);<br>    <span class="hljs-comment">//return (*s == *p || (*p == &#x27;.&#x27; &amp;&amp; *s != &#x27;\0&#x27;)) &amp;&amp; match(s + 1, p) || match(s, p + 2);</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">catdir</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *predix, <span class="hljs-keyword">char</span> *name, <span class="hljs-keyword">char</span> *buf)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">memcpy</span>(buf, predix, <span class="hljs-built_in">strlen</span>(predix));<br>  <span class="hljs-keyword">char</span> *p = buf + <span class="hljs-built_in">strlen</span>(predix);<br>  *p++ = <span class="hljs-string">&#x27;/&#x27;</span>;<br>  <span class="hljs-built_in">memcpy</span>(p, name, <span class="hljs-built_in">strlen</span>(name));<br>  p += <span class="hljs-built_in">strlen</span>(name);<br>  *p++ = <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">char</span> *dir, <span class="hljs-keyword">char</span> *name)</span> </span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> <span class="hljs-title">de</span>;</span><br>  <br>  <span class="hljs-keyword">while</span>(read(fd, &amp;de, <span class="hljs-keyword">sizeof</span>(de)) == <span class="hljs-keyword">sizeof</span>(de)) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(de.name, <span class="hljs-string">&quot;.&quot;</span>) == <span class="hljs-number">0</span> || <span class="hljs-built_in">strcmp</span>(de.name, <span class="hljs-string">&quot;..&quot;</span>) == <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">st</span>;</span><br>    <span class="hljs-keyword">char</span> path[<span class="hljs-number">512</span>];<br>    catdir(dir, de.name, path);<br>  <br>    <span class="hljs-keyword">if</span>(de.inum == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-keyword">if</span>(stat(path, &amp;st) &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;find: cannot stat %s\n&quot;</span>, path);<br>        <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (st.type == T_FILE &amp;&amp; match(de.name, name)) &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, path);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (st.type == T_DIR) &#123;<br>      <span class="hljs-keyword">int</span> subfd;<br>      <span class="hljs-keyword">if</span>((subfd = open(path, <span class="hljs-number">0</span>)) &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;find: cannot open %s\n&quot;</span>, path);<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br>      find(subfd, path, name);<br>    &#125;<br><br>  &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">3</span>) &#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Usage: find dir name\n&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">char</span> dir[DIRSIZ + <span class="hljs-number">1</span>];<br>  <span class="hljs-keyword">char</span> name[DIRSIZ + <span class="hljs-number">1</span>];<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strlen</span>(argv[<span class="hljs-number">1</span>]) &gt; DIRSIZ || <span class="hljs-built_in">strlen</span>(argv[<span class="hljs-number">2</span>]) &gt; DIRSIZ) &#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;dir or name too long...\n&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br><br>  <span class="hljs-built_in">memcpy</span>(dir, argv[<span class="hljs-number">1</span>], <span class="hljs-built_in">strlen</span>(argv[<span class="hljs-number">1</span>]));<br>  <span class="hljs-built_in">memcpy</span>(name, argv[<span class="hljs-number">2</span>], <span class="hljs-built_in">strlen</span>(argv[<span class="hljs-number">2</span>]));<br><br>  <span class="hljs-keyword">int</span> fd;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">st</span>;</span><br><br>  <span class="hljs-keyword">if</span>((fd = open(dir, <span class="hljs-number">0</span>)) &lt; <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;find: cannot open %s\n&quot;</span>, dir);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">if</span>(fstat(fd, &amp;st) &lt; <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;find: cannot stat %s\n&quot;</span>, dir);<br>    close(fd);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (st.type != T_DIR) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s is not a dir\n&quot;</span>, dir);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    find(fd, dir, name);<br>  &#125;<br>  <br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h5><p><img src="https://whileskies-pic.oss-cn-beijing.aliyuncs.com/20210322091153.png" alt="image-20210322091152189"></p><h4 id="xargs-moderate"><a href="#xargs-moderate" class="headerlink" title="xargs (moderate)"></a>xargs (moderate)</h4><h5 id="任务-4"><a href="#任务-4" class="headerlink" title="任务"></a>任务</h5><p>编写一简单版本的UNIX xargs程序，该程序从标准输入中读取多行并将每一行作为一指定程序的参数</p><h5 id="过程-2"><a href="#过程-2" class="headerlink" title="过程"></a>过程</h5><p>xargs从标准输入中读多行，多行按照<code>\n</code>分隔，使用<code>exec</code>系统调用创建子进程执行指定程序，并将标准输入读的参数和该程序原本的参数一并作为该程序参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;user/user.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;kernel/fcntl.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;kernel/param.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_ARG_LEN 512</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">copy_argv</span><span class="hljs-params">(<span class="hljs-keyword">char</span> **ori_argv, <span class="hljs-keyword">int</span> ori_argc, <span class="hljs-keyword">char</span> *new_argv, <span class="hljs-keyword">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ori_argc; i++) &#123;<br>    argv[k] = <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">strlen</span>(ori_argv[i]) + <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">memcpy</span>(argv[k++], ori_argv[i], <span class="hljs-built_in">strlen</span>(ori_argv[i]) + <span class="hljs-number">1</span>);<br>  &#125;<br>  argv[k] = <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">strlen</span>(new_argv) + <span class="hljs-number">1</span>);<br>  <span class="hljs-built_in">memcpy</span>(argv[k++], new_argv, <span class="hljs-built_in">strlen</span>(new_argv) + <span class="hljs-number">1</span>);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">char</span> **s, <span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, s[i]);<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> </span><br><span class="hljs-function"><span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> (argc &lt;= <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Usage: xargx command [arg ...]\n&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">char</span> param[MAX_ARG_LEN];<br>  <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">char</span> ch;<br>  <span class="hljs-keyword">int</span> ignore = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (read(<span class="hljs-number">0</span>, &amp;ch, <span class="hljs-number">1</span>) &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;\n&#x27;</span>) &#123;<br>      <span class="hljs-keyword">if</span> (ignore) &#123;<br>        i = <span class="hljs-number">0</span>;<br>        ignore = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br>      param[i] = <span class="hljs-number">0</span>;<br>      i = <span class="hljs-number">0</span>;<br><br>      <span class="hljs-keyword">int</span> pid = fork();<br>      <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//child</span><br>        <span class="hljs-keyword">int</span> cmd_argc = argc;<br>        <br>        <span class="hljs-keyword">char</span> *cmd_argv[MAXARG];<br><br>        copy_argv(argv + <span class="hljs-number">1</span>, argc - <span class="hljs-number">1</span>, param, cmd_argv);<br>        cmd_argv[cmd_argc] = <span class="hljs-number">0</span>;<br>        <br>        exec(cmd_argv[<span class="hljs-number">0</span>], cmd_argv);<br><br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        wait((<span class="hljs-keyword">int</span> *)<span class="hljs-number">0</span>);<br>      &#125;<br>      <br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <br>      <span class="hljs-keyword">if</span> (!ignore &amp;&amp; i &gt;= MAX_ARG_LEN - <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;xargs: too long arguments...\n&quot;</span>);<br>        ignore = <span class="hljs-number">1</span>;<br>      &#125;<br><br>      <span class="hljs-keyword">if</span> (!ignore) &#123;<br>        param[i++] = ch;<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="运行结果-2"><a href="#运行结果-2" class="headerlink" title="运行结果"></a>运行结果</h5><p><img src="https://whileskies-pic.oss-cn-beijing.aliyuncs.com/20210322092735.png" alt="image-20210322092734417"></p><h4 id="实验测试"><a href="#实验测试" class="headerlink" title="实验测试"></a>实验测试</h4><p><img src="https://whileskies-pic.oss-cn-beijing.aliyuncs.com/20210322093022.png" alt="image-20210322093022342"></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p><a href="https://github.com/whileskies/xv6-labs-2020/tree/util">https://github.com/whileskies/xv6-labs-2020/tree/util</a></p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>6.S081</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
